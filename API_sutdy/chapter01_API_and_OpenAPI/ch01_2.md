## **API 기술하기**

생태계를 개별 서비스라고 생각한다면 개별 서비스가 어떻게 전체 시스템을 형성하는지 알 수 있게 된다.
전체를 이해할 수 있는 큰 그림을 그리려면 개별 서비스가 어떻게 연결돼 있는지를 알아야 한다.
어떤 개별 서비스가 자신을 사용하는 다른 서비스에게 변경을 알리지 않고 자기 자신만 변경해 버린다면 생태계는 제대로 돌아가지 않게 되며, 경우에 따라서는 완전히 박살 나버릴 수도 있다. 이야기를 통해 상황을 알아보자.

### **브리짓 업무**

브리짓이 관리하고 있는 중간 사이즈의 웹 서비스는 여러 서비스가 서로 의존하며 협력하고 있다. 또한 브리짓의 통제 밖에 있는 외부 서비스도 사용한다.
API를 변경하면 종종 문제가 발생하며, 해당 API를 사용하는 서비스가 제대로 동작하지 않게 된다. 결국 생태계에 균열이 생기며 궁극적으로 브리짓이 관리하는 서비스가 전체적으로 실패하게 된다.

브리짓은 이 문제를 효과적으로 해결해야 한다. API가 변경되면 그 변경에 영향받는 개발자가 대응할 수 있도록 미리 알려서 생태계가 깨지지 않고 부드럽게 돌아가게 만들어야 한다. 브리짓은 잠시 생각에 잠겨 이 생태계가 어떻게 돌아가는지 되짚어 본다. 각 서비스는 API를 갖고 있는 API는 더 작은 연산으로 구성된다. 각 연산은 입력을 받아서 결과를 반환한다. 어떤 연산이 기존과 다른 입력을 받도록 변경됐는데, 입력값을 제공해 주는 다른 서비스가 이 변경에 대해 아무런 대응을 하지 않았다면 시스템 연동이 실패하게 된다. 마찬가지로 어떤 연산이 다른 결과를 반환하도록 변경됐는데, 이 결과를 받아 사용하는 서비스가 이 변경에 대해 아무런 대응을 하지 않았다면 역시 실패하게 된다. 브리짓은 API 변경을 추적하는 것이 생태계 전체가 잘 돌아가는 데 매우 중요한 역할을 한다는 결론에 이르렀다. 하지만 API 변경을 어떻게 알아차리고 대응할 수 있을까?

브리짓은 생태계를 깨뜨릴 수 있는 API의 변경사항에 대해 변경 전과 후를 비교 설명할 수 있는 수단이 필요하다고 생각했다.
브리짓은 API의 설명을 비교해서 달라진 부분에 대한 보고서를 생성하는 프로그램을 작성했다.
보고서는 단순해서 새로운 API에 서비스 간 연동 실패를 유발할 중요한 변경사항이 있는지 쉽게 알아볼 수 있다.

만족스러운 결과를 얻게 되자 브리짓은 개발자들에게 정해진 형식에 맞게 API 설명을 작성해달라고 요청한다.
브리짓은 자신의 통제 밖에 있는 외부 서비스가 제공하는 API에 대해서는 별도로 API 설명을 직접 작성해서 추적할 수 있게 됐다.

### **브리짓 해법의 잠재력**

브리짓의 해법은 API에 설명을 추가할 수 있고, 사람들이 그 설명을 작성할 수 있으며, 소프트웨어도 그 설명을 이해할 수 있다는 사실에 근거한다.

이런 접근 방식을 하나의 특정 문제에 대입하고 있지만 이처럼 설명을 이용하는 방식에는 단순히 보고서를 생성하는 것 이상의 더 큰 잠재력이 있다.
예컨대, 문서 생산, 빌드 전 변경 부분 테스트, 불필요한 준비 코드(boilerplate code) 절감 등 더 다양한 곳에 적용할 수 있다.

이제 브리짓의 해법이 현실에서 어떻게 활용되는지 OpenAPI를 통해 살펴보자.