# 개발에 앞서 알면 좋은 기초 지식

3장부터 시작될 스프링 부트 웹 애플리케이션 개발 프로젝트를 진행하기에 앞서 앞으로 도움이 될 내용을 간단히 다루겠다.
실습을 막연히 따라가기보다 애플리케이션이 '어떻게 작동하는지', '왜 이렇게 구성되는지' 생각하며 실습하기 위한 개발 배경지식 위주로 다루겠다.

---
## 서버 간 통신

어떤 포털 사이트를 하나의 서비스 단위로 가정해보자. 즉, 블로그, 카페, 메일 등의 기능들을 하나의 애플리케이션에 통합하겠다는 뜻이다.
서비스를 이렇게 구성한다면 서버를 업데이트하거나 애플리케이션을 유지보수할 때마다 '사이트 작업 중입니다'라는 팻말을 걸고 작업을 해야 한다.
그만큼 개발에 보수적인 입장을 취할 수밖에 없고, 서비스 자체의 규모도 커지기 때문에 서비스를 구동하는 데 걸리는 시간도 길어진다.

이 같은 문제를 해결하기 위해 나온 것이 마이크로서비스 아키텍쳐(MSA; Microservice Architecture)이다.
마이크로서비스 아키텍쳐는 단어 그대로 서비스 규모를 작게 나누어 구성한 아키텍쳐를 의미한다.
앞에서 예를 든 포털 사이트에 마이크로서비스 아키텍쳐를 적용한다면 애플리케이션 하나에 여러 기능을 넣어 개발하지 않고 블로그 프로젝트, 카페
프로젝트, 메일 프로젝트 등 애플리케이션을 기능별로 나눠서 개발하게 된다.

단일 서비스로 구성된 A 포털 사이트는 내부 메서드 호출 등을 통해 원하는 자원을 가져와 사용할 수 있지만 서비스 기능별로 구분해서 B 포털 사이트와
같이 독립적인 애플리케이션을 개발하게 되면 각 서비스 간에 통신해야 하는 경우가 발생한다. 예를 들면, 사용자가 블로그 기능을 사용하기 위해 로그인 
서비스를 거쳐야만 하는 상황 등이 있겠다. 이런 상황에서의 통신을 '서버 간 통신'이라고 말한다.

서버 간 통신은 한 서버가 다른 서버에 통신을 요청하는 것을 의미하며, 한 대는 서버, 다른 한 대는 클라이언트가 되는 구조이다.
몇 가지 프로토콜에 의해 다양한 통신 방식을 적용할 수 있지만 가장 많이 사용되는 방식은 HTTP/HTTPS 방식이다.

---
## 스프링 부트의 동작 방식

스프링 부트에서 spring-boot-starter-web 모듈을 사용하면 기본적으로 톰캣(Tomcat)을 사용하는 스프링 MVC 구조를 기반으로 동작한다.
서블릿(Servlet)은 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술이다. 일반적으로 서블릿은 컨테이너(Servlet Container)
에서 관리한다. 서블릿 컨테이너는 서블릿 인스턴스(Servlet Instance)를 생성하고 관리하는 역할을 수행하는 주체로서 톰캣은 WAS의 역활과 
서블릿 컨테이너의 역할을 수행하는 대표적인 컨테이너이다. 서블릿 컨테이너의 특징은 다음과 같다.

* 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리한다.
* 서블릿 객체는 싱글톤 패턴으로 관리된다.
* 멀티 스레딩을 지원한다.

서블릿에서는 DispatchServlet이 서블릿의 역할을 수행한다. 일반적으로 스프링은 톰캣을 임베드(embed)해서 사용한다.
그렇기 때문에 서블릿 컨테이너와 DispatcherServlet은 자동 설정된 web, xml의 설정값을 공유한다.

DispatcherServlet의 동작을 간략히 살펴보자. (1) DispatcherServlet으로 요청(HttpServletRequest)이 들어오면 DispatcherServlet은
핸들러 매핑(Handler Mapping)을 통해 요청 URI에 매핑된 핸들러를 탐색한다. 여기서 핸들러는 컨드롤러(Controller)를 의미한다.
(2) 그리고 핸들러 어댑터(Handler Adapter)로 컨트롤러를 호출한다. (3) 핸들러 어댑터에 컨트롤러의 응답이 돌아오면 ModelAdnView로 응답을 가공해
반환한다. (4) 뷰 형식으로 리턴하는 컨트롤러를 사용할 때는 뷰 리졸버(View Resolver)를 통해 뷰(View)를 받아 리턴한다.

핸들러 매핑은 요청 정보를 기준으로 어떤 컨트롤러를 사용할지 선정하는 인터페이스다. 핸들러 매핑 인터페이스는 어떤 구현체를 가지며, 
대표적인 구현체 클래스는 다음과 같다.

* BeanNameUrlHandlerMapping
* 빈 이름을 URL로 사용하는 매핑 전략이다.
* 빈을 정의할 때 슬래시('/')가 들어가면 매핑 대상이 된다.
* 예) @Bean("/hello")

* ControllerClassNameHandlerMapping
* URL과 일치하는 클래스 이름을 갖는 빈을 컨트롤러로 사용하는 전략이다.
* 이름 중 Controller를 제외하고 앞부분에 작성된 suffix를 소문자로 매핑한다.

* SimpleUrHandlerMapping
* URL 패턴에 매핑된 컨트롤러를 사용하는 전략이다.

* DefaultAnnotationHandlerMapping
* 어노테이션으로 URL과 컨트롤러를 매핑하는 방법이다.


뷰 리졸버는 뷰의 랜더링 역할을 담당하는 뷰 객체를 반환한다.
여기서 다룰 애플리케이션은 뷰가 없는 REST 형식의 @ResponseBody를 사용할 예정이라 뷰 리졸버를 호출하지 않고 MessageConverter를 거쳐 
JSON 형식으로 반환해서 응답한다. 여기서 MessageConverter는 요청과 응답에 대해 Body 값을 변환하는 역할을 수행한다. 스프링 부트의 
자동 설정 내역을 보면 HttpsMessageConverter 인터페이스를 사용하고 있다.

---
## 레이어드 아키텍쳐

레이어드 아키텍쳐(Layered Architecture)란 애플리케이션의 컴포넌트를 유사 관심사를 기준으로 레이어로 묶어 수평적으로 구성한 구조를 의미한다.
레이어드 아키텍쳐는 여러 방면에서 쓰이는 개념이며, 어떻게 설계하느냐에 따라 용어와 계층의 수가 달라진다.

일반적으로 레이어드 아키텍쳐라 하면 3 계층 또는 4 계층 구성을 의미한다. 이 차이는 인프라(데이터베이스) 레이어의 추가 여부로 결정된다.
이번 장에서는 3계층으로 이뤄진 레이어드 아키텍쳐를 살펴보도록 하겠다.

각 계층은 다음과 같이 구분된다.

* 프레젠테이션 계층
* 애플리케이션의 최상단 계층으로, 클라이언트의 요청을 해석하고 응답하는 역할을 한다.
* UI나 API를 제공한다.
* 프레젠테이션 계층은 별도의 비즈니스 로직을 포함하고 있지 않으므로 비즈니스 계층으로 요청을 위임하고 받은 결과를 응답하는 역할만 수행한다.

* 비즈니스 계층
* 애플리케이션이 제공하는 기능을 정의하고 세부 작업을 수행하는 도메인 객체를 통해 업무를 위임하는 역할을 수행한다.
* DDD(Domain-Driven Design) 기반의 아키텍쳐에서는 비즈니스 로직에 도메인이 포함되기도 하고, 별도로 도메인 계층을 두기도 한다.

* 데이터 접근 계층
* 데이터베이스에 접근하는 일련의 작업을 수행한다.


레이어드 아키텍쳐는 하나의 애플리케이션에도 적용되지만 애플리케이션 간의 관계를 설명하는 데도 사용할 수 있다.
레이어드 아키텍쳐 기반 설계는 다음과 같은 특징을 가진다.

* 각 레이어는 가장 가까운 하위 레이어의 의존성을 주입받는다.
* 각 레이어는 관심사에 따라 묶여 있으며, 다른 레이어의 역할을 침범하지 않는다.
  * 각 컴포넌트의 역할이 명확하므로 코드의 가독성과 기능 구현에 유리하다.
  * 코드의 확장성도 좋아진다.
* 각 레이어가 독립적으로 작성되면 다른 레이어와의 의존성을 낮춰 단위 테스트에 용이하다.


스프링 부트는 별도의 설정 없이 spring-boot-starter-web의 의존성을 사용할 때는 기본적으로 스프링 MVC 구조를 띠게 된다.
Spring MVC는 Model-View-Controller의 구조로 View와 Controller는 프레젠테이션 계층 영역이며, Model은 비즈니스와 데이터 접근 게층의 
영역으로 구분할 수 있다. 다만 스프링 MVC 모델로 레이어드 아키텍쳐를 구현하기 위해서는 역할을 세분화한다. 비즈니스 계층에 서비스를 배치해 엔티티와
같은 도메인 객체의 비즈니스 로직을 조합하도록 하고 데이터 접근 계층에는 DAO(Spring Data JPA에서는 Repository)를 배치해 도매인을 관리한다.

스프링의 레이어드 아키텍쳐는 다음과 같이 설명할 수 있다. 대체로 역할은 동일하다.

* 프레젠테이션 계층
* 상황에 따라 유저 인터페이스(UI; User Interface) 계층이라고도 한다.
* 클라이언트와의 접점이 된다.
* 클라이언트로부터 데이터와 함께 요청을 받고 처리 결과를 응답으로 전달하는 역할이다.

* 비즈니스 계층
* 상황에 따라 서비스(Service) 계층이라고도 한다.
* 핵심 비즈니스 로직을 구현하는 영역이다.
* 트랜잭션 처리나 유효성 검사 등의 작업도 수행한다.

* 데이터 접근 계층
* 상황에 따라 영속(Persistence) 계층이라고도 한다.
* 데이터베이스에 접근해야 하는 작업을 수행한다.
* Spring Data JPA에서는 DAO 역할을 레파지토리가 수행하기 때문에 레파지토리로 대체할 수 있다.


레이어드 아키텍쳐는 일반적인 계층 구조를 기반으로 필요에 따라 조금씩 변형해 사용한다.
가장 중요한 부분은 비즈니스 계층 영역인데, 비즈니스 로직을 어디서 담당할지 결정하고 설계하는 것이 좋다.
비즈니스 로직은 도메인 계층에서 담당하는 것이 일반적이다.

스프링에서 JPA를 사용하면 @Entity 를 정의한 클래스가 도메인 객체가 되며, 이곳에서 비즈니스 로직을 설계하면 좋다.
다만 서비스 레이어에서 비즈니스 로직을 담당하는 경우도 있으므로 이러한 역할과 책임을 구분해서 설계해야 한다.
상황에 맞는 설계 방식을 알아두면 동료와의 협업도 수월해진다.

---
## 디자인 패턴

디자인 패턴(Design Pattern)은 소프트웨어를 설게할 때 자주 발생하는 문제들을 해결하기 위해 고안된 해결책이다.
디자인 패턴에서 '패턴'이라는 단어는 애플리케이션 개발에서 발생하는 문제는 유사한 경우가 많고 해결책도 동일하게 적용할 수 있다는 의미를 내포한다.
그러나 디자인 패턴이 모든 문제의 정답은 아니며, 상황에 맞는 최적의 패턴을 결정해서 사용하는 것이 바람직하다.

---
### 디자인 패턴의 종류

디자인 패턴을 구체화해서 정리한 대표적인 분류 방식으로 'GoF 디자인 패턴'이라는 것이 있다. 여기서 GoR는 'Gang of Four'의 줄임말이고,
디자인 패턴을 구체화하고 체계화해서 분류한 4명의 인물을 의미한다.

* 생성(Creational) 패턴
추상 팩토리(Abstrcat Factory), 빌더(Builder), 팩토리 메서드(Factory Method), 프로토타입(Prototype), 싱글톤(Singleton)

* 구조(Structural) 패턴
어댑터(Adapter), 브리지(Bridge), 컴포지트(Composite), 데코레이터(Decorator), 퍼사드(Facade), 플라이웨이트(Flyweight), 프락시(Proxy)

* 행위(Behavioral) 패턴
책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(Interpreter), 이터레이터(Iterator), 미디에이터(Mediator), 메멘토
(Memento), 옵져버(Observer), 스테이트(State), 스트레티지(Strategy), 템플릿 메서드(Template Method), 비지터(Visitor)


---
## REST API

REST API는 대중적으로 가장 많이 사용되는 애플리케이션 인터페이스이다. 이 인터페이스를 통해 클라이언트는 서버에 접근하고 자원을 조작할 수 있다.
이번 절에서는 REST의 형식 및 규칙을 알아보겠다.

### REST란?

먼저 REST란 'Representational State Transfer'의 약자로, 월드 와이드 웹(WWW)과 같은 분산 하이퍼미디어 시스템 아키텍쳐의 한 형식이다.
주고받는 자원(Resource)에 이름을 규정하고 URI에 명시해 HTTP 메서드(GET, POST, PUT, DELETE)를 통해 해당 자원의 상태를 주고받는 것을 
의미한다.

### REST API란?

먼저 API는 'Application Programming Interface'의 약자로, 애플리케이션에서 제공하는 인터페이스를 의미한다.
API를 통해 서버 또는 프로그램 사이를 연결할 수 있다. 즉, REST API는 REST 아키텍쳐를 따르는 시스템/애플리케이션 인터페이스라고 볼 수 있다.
REST 아키텍쳐를 구현하는 웹 서비스를 RESTful 하다라고 표현한다.

### REST의 특징

* 유니폼 인터페이스

유니폼 인터페이스란 '일관된 인터페이스'를 의미한다. 즉, REST 서버는 HTTP 표준 전공 규약을 따르기 때문에 어떤 프로그래밍 언어로 
만들어졌냐와 상관없이 플랫폼 및 기술에 종속되지 않고 타 언어, 플랫폼, 기술 등과 호환해 사용할 수 있다는 것을 의미한다.

* 무상태성

REST는 무상태성(stateless)이라는 특징을 가진다. 무상태성이란 서버에 상태 정보를 따로 보관하거나 관리하지 않는다는 의미이다.
서버는 클라이언트가 보낸 요청에 대해 세션이나 쿠키 정보를 별도로 보관하지 않는다. 그렇기 때문에 한 클라이언트가 여러 요청을 보내든 여러 클라이언트가
각각 하나의 요청을 보내든 개별적으로 처리한다. 이렇게 구성된 서비스는 서버가 불필요한 정보를 관리하지 않으므로 비즈니스 로직의 자유도가 높고 설계가
단순하다.

* 캐시 가능성

REST는 HTTP 표준을 그대로 사용하므로 HTTP의 캐싱 기능을 적용할 수 있다. 이 기능을 이용하기 위해서는 응답과 요청이 모두 가능한지(Cacheable)
명시가 필요하며, 캐싱이 가능한 경우 클라이언트에서 캐시에 저장해두고 같은 요청에 대해서는 해당 데이터를 가져다 사용한다. 이 기능을 사용하면
서버의 트랜잭션 부하가 줄어 효율적이며 사용자 입장에서 성능이 개선된다.

* 레이어 시스템

REST 서버는 네트워크 상의 여러 계층으로 구성될 수 있다(Layered System). 그러나 서버의 복잡도와 관계없이 클라이언트는 서버와 연결되는 포인트만
알면 된다.

* 클라이언트-서버 아키텍쳐

REST 서버는 API를 제공하고 클라이언트는 사용자 정보를 관리하는 구조로 분리해 설계한다.
이 구성은 서로에 대한 의존성을 낮추는 기능을 한다.