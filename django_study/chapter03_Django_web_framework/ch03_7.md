## **3.7 애플리케이션 개발하기 - View 및 Template 코딩**

앞에서 polls 애플리케이션을 설계할 때 3개의 페이지가 필요했다.
이 3개의 페이지를 보여주기 위해 필요한 뷰와 템플릿을 코딩하겠다.
이를 위해서는 요청에서부터 응답까지의 처리 흐름에 대한 로직이 설계되어야 한다.
개발자가 어떻게 설계하느냐에 따라 달라지겠지만, 여기서는 4개의 URL과 뷰가 필요하다고 판단하고 설계한다.
물론 사용자에게 보여지는 페이지가 3개이므로, 3개의 템플릿이 필요하다.

이를 코딩으로 반영하기 위해 서로 관련있는 URL과 뷰 및 템플릿을 매핑한다.
장고에서 기본적으로 제공해주는 Admin 사이트까지도 포함하도록 하겠다.
중요한 점은 URL과 뷰는 1:1 관계(N:1도 가능)로 매핑된다는 점이다.
이러한 URl/뷰 매핑을 URLconf라고 하며 urls.py 파일에 작성한다.

```
/polls/ index() -> index.html 템플릿을 보여준다.
/polls/5/ detail() -> detail.html 템플릿을 보여준다.
/polls/5/vote vote()    -> vote.html에 있는 폼을 POST 방식으로 처리한다.
/polls/5/results    results()   -> results.html 템플릿을 보여준다.
/admin/ (장고 가능) -> Admin 사이트를 보여준다(장고에서 기본으로 제공함)

* URL 패턴에서 5는 예시로, 질문번호가 채워지는 자리이다.
```

앞서의 설계 내용을 개발하기 위해 아래 순서대로 코딩하겠다.
코딩 순서는 정해진 것은 없지만, 로직의 흐름상 URLconf를 먼저 코딩한 후, 뷰, 템플릿 또는 템플릿, 뷰 순서로 코딩하는 것이 일반적이다.

```
urls.py 작성                // URLconf 내용을 코딩
views.index() 함수 작성     // index.html 템플릿도 같이 작성
views.detail() 함수 작성    // detial.html 템플릿도 같이 작성
views.vote() 함수 작성      // 리다이렉션 처리 들어있음
views.results() 함수 작성   // results.html 템플릿도 같이 작성
```

### **3.7.1 URLconf 코당**

URLconf 설계 내용에 따르면, Admin 사이트까지 포함해서 5개의 URL과 뷰가 필요하다.
그 내용을 그대로 기계적으로 urls.py 파일에 코딩하면 된다.

```
# (1)
from django.contrib import admin
from django.urls import path
from polls import views

urlpatterns = [     # (2)
    path("admin/", admin.site.urls),    # (3)
    path("polls/", views.index, name='index'),  # (4)
    path("polls/<int:question_id>/", views.detail, name='detail'),
    path("polls/<int:question_id>/results/", views.results, name='results'),
    path("polls/<int:question_id>/vote/", views.vote, name='vote'),
]
```

위 소스를 라인별로 설명하겠다.

* (1): 필요한 모듈과 함수를 임포트한다. admin 모듈과 path() 함수는 장고에서 제공하는 것이고, views 모듈은 다음 절에서 코딩할 예정이다.
* (2): URL/뷰 매핑을 정의하는 방식은 항상 동일하므로, 그대로 따라서 코딩한다. URL 패턴 매칭은 위에서 아래로 진행하므로, 정의하는 순서에 유의해야 한다.
* (3): 장고의 Admin 사이트에 대한 RULconf는 이미 정의되어 있는데, 이를 활용하고 있다. Admin 사이트를 사용하기 위해서는 항상 이렇게 정의한다고 알아두자.
* (4): polls 애플리케이션에 대한 URL/뷰 매핑을 정의하고 있다. path() 함수는 중요하므로 따로 설명하도록 하겠다.

path() 함수는 route, view 2개의 필수 인자와 kwargs, name 2개의 선택 인자를 받는다.

* route: URL 패턴을 표현하는 문자열이다. 이 책에서는 URL 스트링이라고도 부른다.
* view: URL 스트링이 매칭되면 호출되는 뷰 함수이다. HttpRequest 객체와 URL 스트링에서 추출된 항목이 뷰 함수의 인자로 전달된다.
* kwargs: URL 스트링에서 추출된 항목 외에 추가적인 인자를 뷰 함수에 전달할 때, 파이썬 사전 타입으로 인자를 정의한다. 여기서는 사용하지 않을 예정이다.
* name: 각 URL 패턴별로 이름을 붙여준다. 여기서 정해준 이름은 템플릿 파일에서 많이 사용된다.

자, 이제 앞에서 코딩한 내용을 살펴보겠다.
각 라인의 의미는 다음과 같다.

만일 요청의 URL이 /admin/이라면 아래 라인이 매칭되고, 장고에서 제공해주는 admin 앱의 URL 매핑 처리에 일임한다.
다음에 배우게 될 include() 함수와 처리 방식이 거의 동일하다.
이처럼 admin 앱의 URLconf를 인용함으로써 장고의 Admin 사이트를 그대로 사용할 수 있다.

```
path('admin/', admin.site.urls),
```

만일 요청의 URL이 /polls/라면 아래 라인이 매칭되고, URL 스트링에서 추출되는 항목이 없으므로 views.index(request)처럼 뷰 함수가 호출된다.
이 URL 패턴의 이름을 index라고 정했다.

```
path('polls', views.index, name='index'),
```

만일 요청의 URL이 /polls/3/이라면 아래 라인이 매칭되고, URL 스트링에서 3이 추출되므로 뷰 함수 호출시 views.detail(request, question_id=3)처럼 인자가 대입된다. 이 URL 패턴의 이름을 detail이라고 정했다.

```
path('polls/<int:question_id>/', views.detail, name='detail'),
```

만일 요청의 URL이 /polls/7/results/라면 아래 라인이 매칭되고, 추출된 7은 파이썬 int타입으로 변환된 후에, 뷰 함수를 호출 시 
views.results(request, question_id=7)처럼 인자가 대입된다. 이 URL 패턴의 이름을 results라고 정했다.

```
path('polls/<int:question_id>/results', views.results, name='results'),
```

만일 요청의 URL이 /polls/9/vote/라면 아래 라인이 매칭되고, 뷰 함수를 호출 시 views.vote(request, question_id=9)처럼 인자가 대입된다.
이 URL 패턴의 이름을 vote라고 정했다.

```
path('polls/<int:question_id>/vote/', views.vote, name='vote'),
```

추가적으로, mysite/settings.py 파일이 ROOT_URLCONF 항목이 정의된다는 것을 기억하길 바란다.
장고는 URL 분석 시, 이 항목에 정의된 urls.py 파일을 가장 먼저 분석하기 시작한다.

```
ROOT_URLCONF = 'mysite.urls'
```

한 가지 더 알아두어야 할 사항은 URLconf를 코딩할 때 앞에서처럼 하나의 urls.py 파일에 작성할 수도 있고,
다음과 같이 mysite/urls.py와 polls/urls.py 2개의 파일에 작성할 수도 있다.

```
# mysite/urls.py

from django.contrib import admin
from django.urls import path, include
from polls import views

urlpatterns = [     
    path("admin/", admin.site.urls),
    path("polls/", include('polls.urls')),
]
```

```
# polls/urls.py

from django.urls import path
from . import views

app_name = 'polls'
urlpatterns = [
    path('', views.index, name='index'),    # /polls/
    path('<int:question_id>/', views.detail, name='detail'),    # /polls/5/
    path('<int:question_id>/results/', views.results, name='results'),  # /polls/5/results/
    path('<int:question_id>/vote/', views.vote, name='vote'),   # /polls/5/vote/
]
```

어떤 방식이 좋을까? 두 번째가 좋은 방법이다.
즉, URLconf 모듈을 계층적으로 구성하는 것이 변경도 쉬워지고, 확장도 용이해지기 때문이다.
만일 URL의 polls를 vote라고 변경한다고 가정했을 때, 1개의 파일로 URLconf를 코딩한 경우는 모든 패턴, 즉 위 예제의 경우 4개의 패턴을 수정해야 하지만, 2개의 URLconf를 코딩한 경우는 상위 URLconf에서 1개의 패턴만 수정하면 된다.
더 중요한 사항은 나중에 yoursite라는 프로젝트에 polls 애플리케이션을 재사용하는 경우, 하위의 URLconf를 그대로 가져가서 사용할 수 있다는 것이다.
이것이 재사용을 기본 원칙으로 하는 장고의 장점 중 하나이다.

그리고 polls/urls.py 파일에서 사용한 app_name 변수는 URL 패턴의 이름이 충돌나는 것을 방지하기 위한 이름 공간namespace 역할을 한다.
우리 예제에서는 애플리케이션이 polls 하나뿐이지만, 보통의 프로젝트에서는 여러 개의 애플리케이션으로 이루어지는 경우가 대부분이다.
예를 들어, polls 애플리케이션의 URL 패턴 이름과 blog 애플리케이션의 URL 패턴 이름이 모두 detail이 되는 경우가 발생할 수 있다.
이 둘을 구별하기 위해 app_name 변수로 이름 공간을 지정하는 것이다.
즉, polls 애플리케이션의 detail은 polls:detail, blog 애플리케이션의 detail은 blog:detail로 표기해서 구분하게 된다.