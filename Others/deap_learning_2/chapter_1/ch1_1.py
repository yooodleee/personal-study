#벡터와 행렬

'''
벡터와 행렬(또는 텐서tensor)이 도처에 등장한다.
벡터-> 크기와 방향을 가진 양-> 숫자가 일렬로 늘어선 집합으로 표현한다.(1차원으로 취급함)
행렬-> 2차원 형태(사각형 형상)로 늘어선 것.

벡터-> 1차원 배열
행렬-> 2차원 배열
가로줄: 행row
세로줄: 열column

세로로 나열하는 방법(열벡터)
가로로 나열하는 방법(행벡터)
'''
import numpy as np

x=np.array([1,2,3])
print(x.__class__)
#<class 'numpy.ndarray'>

print(x.shape)  #배열의 형상
#(3,)

print(x.ndim)   #배열의 차원 수
#1

W=np.array([[1,2,3],[4,5,6]])
print(W.shape)
#(2, 3)

print(W.ndim)
#2


#행렬의 원소별 계산
'''
원소별element-wise 연산
다차원 넘파이 배열의 사칙연산-> 서로 대응하는 원소끼리(각 원소가 독립적으로) 연산이 이뤄진다.
'''
W=np.array([[1,2,3],[4,5,6]])
X=np.array([[0,1,2],[3,4,5]])
print(X+W)
# [[ 1  3  5]
#  [ 7  9 11]]

print(X*W)
# [[ 0  2  6]
#  [12 20 30]]


#브로드캐스트
'''
넘파이의 다차원 배열에서는 형상이 다른 배열끼리도 연산할 수 있다.
-> 브로트캐스트가 진행된 배열끼리 서로 형상이 같아지도록 확장된다.
'''
A=np.array([[1,2],[3,4]])
print(A*10)
# [[10 20]
#  [30 40]]

B=np.array([[1,2],[3,4]])
C=np.array([10,20])
print(B+C)
# [[11 22]
#  [13 24]]


#벡터의 내적과 행렬의 곱
'''
#벡터의 내적

X=(x1, x2, x3,...)
Y=(y1, y2, y3,...)

X*Y = x1*y1 + x2*y2 + x3*y3+...

두 벡터에서 대응하는 원소들의 곱을 모두 더한 것
-> 두 벡터가 얼마나 같은 방향으로 향하고 있는가를 나타낸다.
-> 벡터의 길이가 1인 경우로 한정하면, 완전히 같은 방향을 향하는 두 벡터의 내적은 1이 된다.
-> 반대로 반대 방향을 향하는 두 벡터의 내적은 -1이 된다.

벡터의 내적과 행렬의 곱 모두에 np.dot()을 사용할 수 있다.
np.dot(x,y)의 인수가 모두 1차원 배열면 벡터의 내적을 계산하고, 2차원 배열이면 행렬의 곱을 계산한다.
다만, 가능하면 둘을 구분하여 코드의 논리와 의도를 명확히 해주는 것이 좋다.
'''
#벡터의 내적
a=np.array([1,2,3])
b=np.array([4,5,6])
print(np.dot(a,b))  #32

#행렬의 곱
A=np.array([[1,2],[3,4]])
B=np.array([[5,6],[7,8]])
print(np.matmul(A,B))
# [[19 22]
#  [43 50]]

#행렬의 형상 확인 
'''
행렬이나 벡터를 계산할 때는 형상shape에 주의해야 한다.
행렬 곱의 계산 순서는 항상 형상 확인이 중요하다.
'''