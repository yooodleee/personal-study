# 참조 타입과 참조 변수


자바는 객체 지향 언어이다. 6장에서 본격적으로 객체를 학습하기 전에 먼저 찹조 타입의 종류와 참조 변수의 역할이 
무엇인지 정확히 이해하는 것이 중요하다.
---

자바의 타입은 크게 기본 타입 Primitive type과 참조 타입 Reference tytpe으로 분류된다. 기본 타입은 2장에서 배운 것처럼,
정수, 실수, 문자, 논리 리터럴을 저장하는 타입을 말한다. 지금까지 우리는 기본 타입으로 변수를 선언하고 데이터를 저장하는 연습을 했다.
이번 장부터는 참조 타입에 중점을 두려고 한다. 참조 타입이란 객체 object의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스를 말한다.
---
## 기본 타입과 참조 타입

기본 타입으로 선언된 변수와 참조 타입으로 선언된 변수의 차이점은 저장되는 값이다. 기본 타입인 byte, char, short, int, long, float, double
, boolean 변수는 실제 값을 변수 안에 저장하지만, 참조 타입인 베열, 열거, 클래스, 인터페이스는 메모리의 번지를 변수 안에 저장한다.
번지를 통해 객체를 참조한다는 뜻에서 참조 타입이라고 부른다.

기본 타입 변수    참조 타입 변수    
(실제 값)          (100번지)     -> 100번지(객체)

예를 들어 int 타입과 double 타입으로 선언된 변수 age와 price가 있고, String 클래스로 선언된 name과 hobby가 있다고 가정해보자.
// 기본 타입 변수
int age = 25;
double price = 100.5;

// 참조 타입 변수
String name = "신용권";
String hobby = "독서";

int 타입 변수인 age와 double 타입 변수인 price는 직접 값을 저장하고 있지만, String 클래스 변수인 name과 hobby는 
힙 영역의 String 객체 번지 값을 가지고 있다. 이처럼 번지를 통해 객체를 참조하기 때문에 String 클래스 변수를 참조 변수라고 한다.
---
## 메모리 사용 영역

본격적으로 참조 타입을 알아보기 전에 우선 JVM이 사용하는 메모리 영역에 대해서 알아보겠다. JVM은 운영체제에서 할당받은 메모리 영역
Runtime Data Area을 다음과 같이 세부 영역으로 구분해서 사용한다.
메모리 영역(Runtime Data Area)-> 메서드 영역(Method Area), 힙 영역(Heap Area), JVM 스택(Stack)

1. 메서드 영역(Method Area)

메서드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다. 메서드 영역에는 코드에서 사용되는 클래스 ~.class들을 클래스 로더로 읽어
클래스 별로 정적 필드 static field와 상수 constant, 메서드 코드, 생성자 constructor 코드 등을 분류해서 저장한다.

2. 힙 형역(Heap Area)

힙 영역은 객체와 배열이 생성되는 영역이다. 여기에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
만일 참조하는 변수나 필드가 없다면 의미 없는 객체가 되기 때문에 JVM이 이것을 쓰레기로 취급하고 쓰레기 수집기 Garbage Collector를 실행시켜
자동으로 제거한다. 따라서 개발자는 객체를 제거하기 위해 별도의 코드를 작성할 필요가 없다. 사실 자바는 코드로 객체를 직접 제거하는 방법을 제공하지 않는다.

3. JVM 스택 영역(Stack)

JVM 스택은 메서드를 호출할 때마다 프레임 Frame을 추가 Push하고 메서드가 종료되면 해당 프레임을 제거 Pop하는 동작을 수행한다.
프레임 내부에는 로컬 변수 스택이 있는데, 기본 타입 변수와 참조 타입 변수가 추가 Push되거나 제거 Pop된다. 스택 영역에 변수가 생성되는 시점은
초기화가 될 때, 즉, 최초로 변수에 값이 저장될 때이다. 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.

---
## null과 NullPointerException

참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있다. null 값도 초기값으로 사용될 수 있기 때문에 null로 초기화된 변수는
스택 영역에 생성된다. 참조 타입 변수가 null 값을 가지는지 확인하려면 ==, != 연산을 수행하면 된다.

자바는 프로그램 실행 도중에 발생하는 오류를 예외 Exception라고 부른다. 예외는 사용자의 잘못된 입력으로 발생할 수 있고,
프로그래머가 코드를 잘못 작성해서 발생할 수도 있다. 참조 변수를 사용하면서 가장 많이 발생하는 예외 중 하나로 NullPointerException이 있다.
이 예외는 찹조 타입 변수를 잘못 사용하면 발생한다.

참조 변수가 null을 가지고 있을 경우에는, 참조 객체가 없으므로 변수를 통해 객체를 사용할 수 없다. 만약 null 상태에서 있지도 않은 객체의 
데이터(필드)나 메서드를 사용하는 코드를 실행하면 NullPointerException이 발생한다.
int[] intArray = null;
intArray[0] = 10;   // NullPointerException

위 코드에서 intArray는 배열 변수이므로 참조 변수이다. 그래서 null로 초기화가 가능하다. 이 상태에서 intArray[0]에 10을 저장하려고 하면
NullPointerException이 발생한다. intArray 변수가 참조하는 배열 객체가 없기 때문이다.
다른 코드를 보도록 하자.
String str = null;
System.out.println("총 문자 수 : " + str.length());  // NullPointerException

String은 클래스이므로 참조 타입이다. 따라서 str 변수도 null로 초기화할 수 있다. 이 상태에서 String 객체의 length()라는 
메서드를 호출하면 NullPointerException이 발생한다. 이유는 str 변수가 참조하는 String 객체가 없기 때문이다. NullPointerException이 
발생했을 때 해결 방법은 참조 변수를 추적해서 객체를 참조하도록 수정하는 것이다.

---
## String 타입

자바는 문자열을 String 변수에 저장하기 때문에 다음과 같이 String 변수를 우선 선언해야 한다.
String 변수;

String 변수에 문자열을 저장하려면 큰따옴표로 감싼 문자열 리터럴을 대입한다.
변수 = "문자열";

변수 선언과 동시에 문자열을 저장할 수도 있다.
String 변수 = "문자열";

다음은 2개의 String 변수를 선언하고 문자열을 저장한다.
String name;
name = "신용권";
String hobby = "자바";

사실 문자열을 String 변수에 저장한다는 말은 엄밀히 말해 틀린 표현이다.
문자열이 직접 변수에 저장되는 것이 아니라, 문자열은 String 객체로 생성되고 변수는 String 객체를 참조하기 때문이다.
하지만 일반적으로 String 변수에 저장한다고 표현한다. 

자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어 있다. 다음과 같이 name1과 name2 변수가 동일한 문자열 리터럴인 
"신용권"을 참조할 경우 name1과 name2는 동일한 String 객체를 참조하게 된다.
String name1 = "신용권";
String name2 = "신용권";

일반적으로 변수에 문자열을 저장할 경우에는 문자열 리터럴을 사용하지만, new 연산자를 사용해서 직접 String 객체를 생성시킬 수도 있다.
new 연산자는 힙 영역에 새로운 객체를 만들 때 사용하는 연산자로 객체 생성 연산자라고 한다.
String name1 = new String("신용권");
String name2 = new String("신용권");

문자열 리터럴로 생성하느냐 new 연산자로 생성하느냐에 따라 비교 연산자의 결과는 달라질 수 있다. 동일한 문자열 리터럴로 String 객체를 
생성했을 경우 == 연산의 결과는 true가 나오지만, new 연산자로 String 객체를 생성했을 경우 == 연산자의 결과는 false가 나온다.
== 연산자는 변수에 저장된 객체의 번지가 동일한지를 검사하기 때문이다.

name1과 name2는 동일한 문자열 리터럴로 생성된 객체를 참조하기 때문에 name1 == name2의 결과는 true가 나온다.
그러나 name3은 new 연산자로 String 객체를 별도로 생성했기 때문에 name1 == name3은 false가 나온다.

동일한 String 객체이건 다른 String 객체이건 상관없이 내부 문자열을 비교하고 싶을 때에는 String 객체의 equals() 메서드를 
사용해야 한다. equals() 메서드는 원본 문자열과 매개값으로 주어진 비교 문자열이 동일한지 비교한 후 true 또는 false를 리턴한다.