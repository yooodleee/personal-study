// 02-3. 변수의 유효 범위와 형식 변환

/*
변수의 유효 범위

변수를 선언했다고 해서 프로그램 어느 곳에서나 사용할 수 있는 것은 아니다.
변수가 선언된 위치에 따라 사용할 수 있는 범위가 결정된다.
예컨대 함수에서 value라는 변수를 선언하면 value는 해당 함수에서만 사용할 수 있다.
이를 지역 범위(local scope)라고 한다.

같은 지역 범위에서 이름이 같은 변수가 없는 '단일 정의 규칙'만 잘 지킨다면, 다른 범위에서는 같은 이름으로 변수를 선언해도 오류가
발생하지 않는다.

C++ 언어에는 더 많은 종류의 범위가 있다.
대표적인 범위를 정리하면 다음과 같다.
    1) 구문 범위:
        if, for, while 등의 구문 안에서만 유효하다.
    2) 지역 범위:
        매개변수 이름을 포함하여 함수 안에 선언한 이름은 해당 함수 내에서만 유효하다.
        지역 범위는 블록 범위(block scope)라고도 한다.
    3) 전역 범위:
        네임스페이스나 클래스, 함수 등에 속하지 않고 외부에 선언한 이름이다.
        선언 지점부터 파일 끝까지 유효하다.
    4) 클래스 범위:
        클래스 멤버의 이름은 선언 지점에 관계없이 클래스 정의 전체에 걸쳐 확장된다.
        클래스 멤버에 대한 접근성은 접근 지정자(public, private)로 제어할 수 있다.
    5) 네임스페이스 범위:
        네임스페이스 안에 선언한 이름은 네임스페이스 안에서만 유효하다.
        네임스페이스는 서로 다른 파일들의 여러 블록에서 선언될 수 있다.


지역 범위 내에 전역 변수와 이름이 같은 변수가 없다면 컴파일러는 전역 변수에 접근한다.
그러나 지역 범위 내에 전역 변수와 이름이 같은 변수가 있다면 지역 변수의 우선권이 더 높다.
이때 전역 범위 연산자:: 를 사용하면 전역 변수에 접근할 수 있다.

하지만 전역 변수와 이름이 같은 지역 변수를 정의하는 것은 피해야 한다.
의도치 않은 실수가 발생할 수 있기 때문이다.
전역 변수에는 'g_'와 같은 접두사를 붙여 g_value처럼 정의한다면 이름만으로도 지역 변수와 구분할 수 있어 실수를 방지할 수 있다.
*/

/*
L-value와 R-value 비교

C언어에서 L-value와 R-value는 각각 왼쪽 값과 오른쪽 값을 의미한다.
대입 연산자(=)를 기준으로 왼쪽 항을 L-value라고 하고, 오른쪽 항을 R-value라고 한다.
대표적인 예로 L-value는 변수, R-value는 상수가 있다.

하지만 C++ 언어에서는 L-value와 R-value를 단순히 대입 연산자 기준으로만 구분하지 않는다.
표준 C++ 에서 L-value와 R-value의 의미는 다음과 같다.

    L-value: 주로 대입 연산자의 왼쪽에 나타나는 값으로, 메모리 위치를 가리키거나 수정할 수 있는 표현식
        (예: 변수 이름, 배열 요소, 클래스 멤버)
    R-value: 주로 대입 연산자의 오른쪽에 나타나는 값으로, 임시 값이나 메모리상에 위치가 없는 값을 가리키는 식
        (예: 임시 객체, 리터럴)

C++ 언어에서 L-value와 R-value의 구분은 변수와 표현식이 어떻게 사용되는지 이해하고 코드를 작성할 때 오류를 방지하는 데
도움이 된다. L-value와 R-value의 특징을 비교하면 다음과 같다. 

<L-value와 R-value의 비교> 
1) L-value:
    * 주로 대입 연산자의 좌변에 나타난다. 
    * 메모리 위치를 가리킨다. 
    * 이름이 있다. 
    * 사용되는 식 외에서도 유효하다. 
2) R-value: 
    * 주로 대입 연산자의 우변에 나타난다. 
    * 메모리 위치를 가리키지 않는다. 
    * 대체로 이름이 없다. 
    * 사용되는 식에서만 임시로 유효하다. 
*/

/*
형식 변환

프로그래밍을 하다 보면 변수의 형식을 변경해서 사용해야 할 때가 있다. 
이를 위해 C++ 언어에서는 '암시적 형 변환'과 '묵시적 형 변환', 이렇게 두 가지 방법의 형식 변환(type casting)을 지원한다. 
각각을 정의하면 다음과 같다. 

    * 암시적 형 변환(Implicit cast): 
        컴파일러가 자동으로 변경
    * 묵시적 형 변환(Explicit cast):
        개발자가 의도적으로 직접 변경


* 암시적 형 변환

    먼저 암시적 형 변환의 예를 보겠다.

    #include <iostream>
    using namespace std;

    int main()
    {
        float float_value = 1.5f;   // 원본 데이터는 부동 소수점 형 1.5

        double double_value = float_value;  // 숫자 승격: 데이터 유실 없음
        int int_value = float_value;        // 숫자 변환: 데이터 유실 발생

        cout << "float_value" << float_value << endl;
        cout << "double_value" << double_value << endl;
        cout << "int_value" << int_value << endl;

        return 0;
    }

    이 코드에서 컴파일러가 자동으로 형식을 변환하는 암시적 형 변환은 두 곳에서 발생한다.
    다음 코드에서는 float 형과 같은 계열이면서 더 큰 부동소수점 자료형인 double로 변환된다.
    이를 숫자 승격(numeric promotion)이라고 하며, 이때 데이터는 그대로 유지된다. 

    숫자 승격 예(데이터 유지)
        double double_value = float_value;

    반면에 다음 코드처럼 부동 소수점에서 정수로 서로 다른 자료형으로 변환하거나, 또는 크기가 더 작은 자료형으로 변환하면
    숫자 변환(numeric conversion)이 발생된다. 
    이때는 데이터가 유실될 가능성이 있다. 
    실행 결과를 보면 소수점 아래 데이터가 유실되어 정수 데이터 1만 남게 되는 것을 확인할 수 있다. 

    숫자 변환 예(데이터 유실)
        int int_value = float_value;


    * 컴파일할 때 발생하는 결과도 꼭 살펴보자.

        숫자 변환이 발생하면 컴파일러는 다음과 같은 경고(warning) 메시지로 데이터가 유실될 수 있음을 알려 준다. 

        warning C4244: '초기화 중': 'float'에서 'int'(으)로 변환하면서 데이터가 유실될 수 있습니다. 

        컴파일을 진행할 때 오류(error) 메시지만 해결해도 실행 파일은 만들어진다. 
        이 때문에 경고 메시지를 무시하고 넘어가는 경우가 있다. 
        하지만 경고 메시지를 잘 살펴보면 의도치 않은 오동작을 찾아내어 런타임 오류를 막을 수 있다. 
        경고 메시지도 꼼꼼히 확인하는 습관을 들이는 것이 좋다. 


    명시적 형 변환

    #include <iostream>
    using namespace std;

    int main()
    {
        int int_a = 10;
        int int_b = 5;

        int int_avg = (int_a + int_b) / 2;

        float float_avg_1 = (int_a + int_b) / 2;    // 암시적 형 변환: 데이터 유실
        float float_avg_2 = float(int_a + int_b) / 2; // 명시적 형 변환

        cout << "int_avg: " << int_avg << endl;
        cout << "float_avg_1: " << float_avg_1 << endl;
        cout << "float_avg_2: " << float_avg_2 << endl;

        return 0;
    }

    먼저 암시적 형 변환이 발생한 곳부터 살펴보자. 
    다음 코드는 두 정수의 평균을 구하는 식이다. 
    소수점이 발생할 수 있으므로 결괏값을 float 형으로 받도록 했다. 

    float float_avg_1 = (int_a + int_b) / 2;

    그런데 결괏값(float_avg_1)을 확인해 보면 소수점 데이터가 유실된 것을 발견할 수 있다. 
    어떻게 이런 결과가 나왔을까?
    컴파일러는 int_a + int_b 부분을 정수형 R-value로 처리함으로써, '정수형 R-value/2'의 결과도 정수가 된 것이다. 
    결괏값을 float형으로 구하려 했지만, 이미 정수끼리 나누기 연산에서 소수점 데이터가 사라져 의도치 않은 결과가 나온 것이다. 

    이러한 문제를 해결하기 위해 개발자가 의도적으로 원하는 시점에 형식을 변환할 수 있도록 하는 것이 '명시적 형 변환'이다. 
    이번에는 명시적 형 변환으로 원하는 값이 나온 코드를 살펴보자. 

    float float_avg_2 = float(int_a + int_b) / 2;

    int_a + int_b 부분을 float 형 R-value로 변환할 것을 명시적으로 표기함으로써 이후의 연산은 모두 float형으로 처리된다. 
    따라서 데이터가 유실되지 않고 온전한 결괏값을 얻을 수 있다. 

    C++ 언어에서는 float() 형태뿐만 아니라 (float)처럼 C 언어 방식의 명시적 형 변환도 지원한다. 

    float float_avg_2 = (float)(int_a + int_b) / 2;

    앞에서 설명한 명시적 형 변환 외에 C++ 언어에서는 static_cast, const_cast, dynamic_cast, reinterpart_cast 등
    다양한 방법으로 명시적 형 변환을 지원한다. 
    다음 표에는 아직 배우지 않은 개념도 있으므로 참고도 알아두도록 하자. 

    
    <명시적 형 변환 방법> 
        1) static_cast <변환_형식>(변환_대상)
            논리적으로 변경할 수 있는 형 변환 모두 가능
            상속 관계에 있는 포인터끼리 변환도 지원
        2) const_cast <변환_형식>(변환_대상)
            포인터 및 레퍼런스 형식에서만 사용 가능
            const, volatile 제거할 때 사용
        3) reinterpret_cast <변환_형식>(변환_대상)
            일반적인 명시적 형 변환과 동일함
            const를 사용하는 변환 대상은 사용할 수 없음
        4) dynamic_cast <변환_형식>(변환_대상)
            클래스의 포인터 및 레퍼런스 변수 간의 형 변환 시 사용
            안전한 다운캐스팅(down-casting)을 위해 사용

    
    * 명시적 형 변환이 필요한 이유는 무엇인가?
        명시적 형 변환은 데이터 손실을 방지할 때, 변수의 범위를 초과하는 값을 적절한 범위로
        조절할 때, 서로 다른 데이터 유형끼리 계산할 때 등 데이터 유형 간의 호환성이나 연산의
        정확성을 유지할 목적으로 사용한다. 그러나 형 변환을 남용하면 코드를 해석하기 어렵게 
        되므로 신중하게 사용해야 한다. 
*/
