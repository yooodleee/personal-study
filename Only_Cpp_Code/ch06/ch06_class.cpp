// 클래스와 인스턴스

/**
 * 클래스란 무엇인가
 * 
 * 객체지향 프로그래밍은 데이터와 함수를 포함하는 객체를 활용하는 프로그래밍 패러다임이며, 
 * 다양한 객체 간에 관계를 소스 코드로 구성하여 프로그램을 완성한다. 여기서 데이터와 함수를
 * 포함하는 논리 단위를 객체(object)라고 하지만 클래스(class)라고 하기도 한다. 이는 
 * '데이터 형식'과 '변수'의 관계와 비교할 수 있다. 
 * 
 * 변수는 값을 저장할 수 있는 공간이고 어떤 형식의 값이 저장되는지 데이터 형식으로 컴파일러에게
 * 알려 준다. 여기서 클래스는 데이터 형식이고, 객체는 변수라고 할 수 있다. 즉, 클래스는 객체가 
 * 포함하는 데이터와 함수를 정의하는 문법적인 요소이고, 객체는 특정 클래스를 사용할 수 있도록 
 * 만든 변수이다. 
 * 
 * 클래스를 정의할 때는 객체가 가질 데이터와 함수를 작성한다. 이때 클래스가 포함하는 데이터를 
 * '멤버 변수', 함수를 '멤버 함수'라고 한다. 멤버 변수는 클래스의 속성을, 멤버 함수는 클래스의
 * 행동을 나타낸다. 그리고 생성자와 소멸자라는 특별한 함수도 포함할 수 있다. 생성자는 객체가
 * 생성될 때, 소멸자는 객체가 소멸할 때 자동으로 호출되는 함수이다. 
 * 
 * 멤버 변수와 멤버 함수를 정의할 때는 public, private와 같은 접근 지정자가 필요하다. 접근 
 * 지정자는 접근 범위를 통제하는 역할을 한다. 
 */

/**
 * 클래스 정의 문법
 * 
 * 클래스를 정의하는 문법을 보면 크게 '클래스 선언부'와 '멤버 함수 정의부'로 나눌 수 있다. 
 * 각 요소를 어떻게 작성하는 지 다음을 통해 살펴보도록 하자. 
 * 
 * => 클래스 선언부: 멤버 변수, 멤버 함수, 생성자, 소멸자
 * => 멤버 함수 정의부: 멤버 함수 정의
 */

// (1) gs_engine: 클래스 이름	(2) ic_engine: 부모 클래스(선택)
class gs_engine : public ic_engine {		// 
public:	// (3) 접근 지정자
	gs_engine();				// (4) 생성자
	~gs_engine();				// (4) 소멸자(~)

	int get_current_fuel()		// (5) 멤버 함수 선언과 구현
	{
		return current_fuel;
	};	


private:	// (3) 접근 지정자
	void acceleration_output() override;	// (5) 멤버 함수 선언과 구현
	void increasing_fuel() 
	{				
		increasing_piston_speed();			// (5) 멤버 함수 선언과 구현
	};
	void increasing_piston_speed() {};

	int current_fuel;			// (6) 멤버 변수 선언
	int piston_speed;			// (6) 멤버 변수 선언

};

//				(7) 멤버 함수 네임 스페이스
void gs_engine::acceleration_outout() {		// (8) 멤버 함수 정의부
	increasing_fuel();
	current_fuel++;
}