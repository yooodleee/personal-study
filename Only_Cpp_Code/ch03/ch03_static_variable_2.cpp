// static 변수를 이용한 아이디 생성 함수 만들기

/**
 * static 변수의 특징을 통해 프로그래밍을 매우 유용하게 작성할 수 있다. 
 * 다음처럼 아이디를 차례로 생성하는 코드도 static 변수를 이용하면 간단하게 작성할 수 있다. 
 */

#include <iostream>
using namespace std;


int getNewID() {

	// 정적 변수는 메모리의 데이터 영역에 할당되므로 프로그램 실행부터 종료까지 값이 유지된다.
	static int ID = 0;
	return ++ID;
}

int main() {
	// 정적 변수 호출 => 호출될 때마다 1씩 증가(후위 증가 연산자)
	cout << "ID : " << getNewID() << endl;
	cout << "ID : " << getNewID() << endl;
	cout << "ID : " << getNewID() << endl;
	cout << "ID : " << getNewID() << endl;
	cout << "ID : " << getNewID() << endl;

	return 0;
}

/*
ID : 1
ID : 2
ID : 3
ID : 4
ID : 5
*/

/**
 * 정적 변수의 수명 주기가 지역 변수와 다른 이유
 * 
 * 지역 변수와 정적 변수는 메모리의 위치가 다르다. 프로그램의 메모리 구조를 보면 알 수 있다. 
 * 
 * 지역 변수는 메모리구조에서 스택(stack) 영역에 저장된다. 스택 영역의 변수는 함수가 호출될 때
 * 메모리에 할당되며 종료될 때 메모리에서 해제된다. 하지만 static으로 선언된 정적 변수는 데이터
 * (data) 영역에 저장된다. 이처럼 지역 변수와 정적 변수는 할당되는 메모리 영역이 달라 수명 주기가
 * 다르다. 
 * 
 * * static 변수는 언제 사용되는가?
 * static은 처음에 한 번만 초기화되고 그 값은 함수나 클래스의 인스턴스를 여러 번 호출할 때도 지속된다. 
 * 클래스나 함수의 모든 인스턴스 간에 공유되는 변수를 선언하고 싶지만, 해당 클래스나 함수 외부에서
 * 보이지 않게 하고 싶을 때 static을 주로 사용힌다. 예컨대 어떤 클래스가 얼마나 많은 객체를 생성했는지
 * 셀 때 유용하다. 
 */

/**
 * 상수 변수 선언하기 - const
 * 
 * 상수(constant)란 변하지 않는 값을 의미한다. 값을 변경할 수 있는 변수와는 상반된 개념이다. 
 * 그런데 변수에 const 키워드를 사용하면 값을 변경할 수 없게 된다. 즉 상수가 된다. 
 * 
 * 이처럼 변수를 상수화하려면 자료형 앞이나 뒤에 const 키워드를 붙이면 된다. 다만, 가독성을 위해
 * 자료형 앞에 붙이는 것을 추천한다. 
 * const int a = 1;
 * int const b = 1;
 * 
 * const 변수를 사용할 때는 반드시 초기화해야 하며, 초기화하지 않으면 컴파일 오류가 발생한다. 
 * 그리고 const 변수를 초기화한 후에 새로운 값을 넣으려고 한다면 컴파일 오류가 발생한다. 
 * 
 * * const로 지정한 변수에 값의 대입을 시도한 경우
 * #include <iostream> 
 * using namespace std;
 * 
 * int main()
 * {
 * 		const int a = 1;
 * 		a = 2;				// 컴파일 오류 발생
 * 
 * 		return 0;
 * }
 */

/**
 * 포인터 변수의 상수화
 * 
 * 일반 변수를 상수화하는 것은 컴파일 오류만 주의하면 되지만, 포인터 변수를 상수화할 때는 const 키워드의
 * 위치에 따라 상수화할 대상이 달라지므로 구분해서 사용해야 한다. 먼저 포인터 변수가 가리키는 값을 상수화하는
 * 예를 살펴보자. 
 * 
 * * 포인터 변수가 가리키는 값을 상수화
 * #include <iostream> 
 * using namespace std;
 * 
 * int main()
 * {
 * 		int a = 0;
 * 		const int *ptr = &a;	// *ptr을 상수화
 * 
 * 		a = 1;		// 컴파일 통과
 * 		*ptr = 2;	// 컴파일 오류 발생
 * 
 * 		return 0;
 * }
 * 
 * 먼저, a = 1에서 a는 일반 변수이므로 컴파일에 문제가 없다. 반면에 *ptr = 2 코드는 ptr 포인터 변수가 가리키는
 * *ptr이 const로 지정되었으므로 컴파일 오류가 발생한다. 여기서 알 수 있는 점은 포인터 변수가 가리키는 a 변수 
 * 자체가 상수화되지 않는다는 것이다. 
 * 
 * 그럼 const의 위치가 다른 예도 살펴보자. 
 * 
 * 포인터 변수 자체를 상수화
 * #include <iostream> 
 * using namespace std;
 * 
 * int main()
 * {
 * 		int a = 0;
 * 		int b = 1;
 * 		int *const ptr = &a;		// ptr을 상수화
 * 
 * 		a = 1;		// 컴파일 통과
 * 		ptr = &b;	// 컴파일 오류 발생
 * 
 * 		return 0;
 * }
 * 
 * 이번에도 a = 1에서 a는 일반 변수이므로 컴파일에 문제가 없다. 하지만 ptr = &b 코드에서는 ptr 포인터 변수 자체를
 * const로 지정했으므로 컴파일 오류가 발생한다. 
 * 
 * 포인터 변수는 주소를 저장하는 변수다. 즉, 포인터 변수 자체가 상수화되어 다른 변수인 b의 주소로 변경할 수 없게 된다. 
 * 결국 ptr 변수는 오직 a 변수의 주소만 가지게 된다. 
 * 
 * 포인터의 개념과 const 개념이 섞여서 조금 헷갈릴 수 있다. 
 * const의 위치에 따른 상수화 효과를 다음처럼 정리할 수 있다. 
 * 즉, const는 어느 곳에 있던 const가 붙으면 해당 값은 변경할 수 없다라는 것만 기억하면 된다. 
 * 
 * const int *ptr = &a ==> *ptr 상수화 = 포인터 변수가 가리키는 값을 상수화
 * int *const ptr = &a ==> ptr 상수화 = 포인터 변수 자체를 상수화
 */