// 레퍼런스 재지정 불가

/**
 * 레퍼런스를 사용할 때 지켜야 할 점
 * 
 * 레퍼런스를 사용할 때 지켜야 할 점이 있다. 굳이 외우려 하기보다는 각각의 사례를 보면서 이해하면 충분히 
 * 기억할 수 있다. 
 * 
 * 1) 레퍼런스 변수는 선언 후 반드시 참조할 원본 변수를 지정해야 한다. 
 * 		=> 올바른 레퍼런스 선언
 * 			int value = 10;
 * 			int &ref_value = value;
 * 
 * 		=> 잘못된 레퍼런스 선언
 * 			int &ref_invalid_value;		// 컴파일 오류 발생
 * 		
 * 		레퍼런스 변수를 선언할 때 참조할 원본 변수를 지정하지 않으면 컴파일 오류가 발생한다. 
 * 		즉, 레퍼런스 변수는 다른 변수에 종속적이며 독립적으로 존재할 수 없다. 
 * 
 * 2) 참조할 대상이 지정된 레퍼런스 변수는 다른 변수를 참조하도록 변경할 수 없다. 
 * 		다음은 ref_value라는 레퍼런스 변수를 선언하면서 value 변수로 초기화한 후 다시
 * 		value2 변수를 대입했다. 즉, value2를 참조하도록 재지정했다. 
 */

#include <iostream>
using namespace std;


int main() {

	int value = 10;
	int& ref_value = value;

	int value2 = 20;
	ref_value = value2;		// 레퍼런스 재지정, 의도와 다르게 동작 

	cout << "value: " << value << endl;
	cout << "ref_value: " << ref_value << endl;

	return 0;
}

/*
value: 20
ref_value: 20
*/

/**
 * 실행 결과를 보면 의도와 다르게 value2의 값 20이 ref_value에 저장되어 value의 값이 20으로
 * 바뀐다. 이처럼 한 번 초기화된 레퍼런스 변수는 다시 지정하지 않도록 한다. 그래야 코드를 
 * 읽기 쉽고 의도치 않은 동작을 방지할 수 있다. 
 */

/**
 * 3) 레퍼런스 변수는 상수를 참조할 수 없다. 
 * 
 * 상수란 변하지 않는 값을 의미한다. 또한 const 키워드로 지정된 변수 역시 상수이다. 
 * 상수는 리터럴(literal)인데, 리터럴이 있는 메모리 공간은 읽기만 가능하다. 따라서 
 * 해당 영역을 참조하여 값을 변경할 수 없도록 상수를 참조하는 것은 금지되어 있다. 
 * 
 * 만약 다음처럼 상수를 참조하려 한다면 컴파일 오류가 발생한다. 
 * int &ref_invalid_value = 50;
 * 
 * 만약 레퍼런스 변수를 다음처럼 const 상수로 만든다면 컴파일은 통과할 수 있지만, 여전히
 * 값을 변경할 수는 없으므로 의미가 없다. 
 * const int &ref_invalid_value = 50;
 */

/**
 * 세 가지 함수 호출 방식
 * 
 * 앞서 값을 교환하는 예시에서 일반 변수를 활용하는 '값에 의한 호출'과 레퍼런스 변수를 활용하는
 * '참조에 의한 호출'을 다뤘다. 여기서는 포인터 변수를 활용하는 '주소에 의한 호출(call by address)'까지
 * 함께 정리해서 살펴보도록 한다. 
 * 
 * 
 * [값에 의한 호출]
 * 		- 함수 원형: void swap(int _a, int _b)
 * 		- 매개변수 : 일반 변수
 * 		- 코드 예  : 
 * 				void swap(int _a, int _b)
 * 				{
 * 					int temp = _a;
 * 					_a = _b;
 * 					_b = temp;
 * 				}
 * 				
 * 				int main()
 * 				{
 * 					int a = 5, b = 10;
 * 					swap(a, b);
 * 					return 0;
 * 				}
 * 
 * 		- swap 이전: a: 5, b: 10
 * 		- swap 이후: a: 5, b: 10
 * 
 * 
 * [참조에 의한 호출]
 * 		- 함수 원형: void swap(int &_a, int &_b)
 * 		- 매개변수 : 레퍼런스 변수
 * 		- 코드 예  :
 * 				void swap(int &_a, int &_b)
 * 				{
 * 					int temp = _a;
 * 					_a = _b;
 * 					_b = temp;
 * 				} 
 * 				
 * 				int main()
 * 				{
 * 					int a = 5, b = 10;
 * 					swap(a, b);
 * 					return 0;
 * 				}
 * 
 * 		- swap 이전: a: 5, b: 10
 * 		- swap 이후: a: 10, b: 5
 * 
 * 
 * [주소에 의한 호출]
 * 		- 함수 원형: void swap(int *_a, int *_b)
 * 		- 매개변수 : 포인터 변수
 * 		- 코드 예: 
 * 				void swap(int *_a, int *_b)
 * 				{
 * 					int temp = *_a;
 * 					*_a = *_b;
 * 					*_b = temp;
 * 				}
 * 
 * 				int main()
 * 				{
 * 					int a = 5, b = 10;
 * 					swap(&a, &b);
 * 					return 0;
 * 				}
 * 
 * 		- swap 이전: a: 5, b: 10
 * 		- swap 이후: a: 10, b: 5
 */

/**
 * 값에 의한 호출은 값 자체만 swap 함수의 매개변수로 복사되어 전달되므로 swap 호출 이전과 
 * 이후의 변화가 없다. 그러나 참조에 의한 호출에서는 main의 a, b 변수에 각각 또 다른 이름 _a, _b가
 * 생긴 것이므로 _a, _b 사이의 값 교환은, 곧 main 내 a, b 변수 사이의 값 교환과 같은 효과가 
 * 나타난다. 
 * 
 * 그리고 주소에 의한 호출에서는 swap 함수가 호출될 때 포인터 변수 _a, _b가 각각 main 내 a, b 변수의
 * 주소를 가리킨다. swap 함수 내에서는 역참조 연산자 *를 통해 _a, _b가 가리키는 주소에 접근하여 값을
 * 교환하므로 main의 a, b 변숫값이 서로 바뀐다. 
 */