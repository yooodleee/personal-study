// new, delete로 동적 메모리 할당하고 해제하기 

/**
 * 동적 메모리 할당
 * 
 * 이번에는 new와 delete를 사용한 동적 메모리 할당을 알아보겠다.
 * 
 * 배열을 사용할 때도 이미 정해진 크기만큼의 고정 배열을 선언하고 사용했다. 
 * 
 * char char_array[10];
 * int int_array[500];
 * float float_array[1000];
 * 
 * 배열의 크기가 고정되다 보니 더 많은 요소가 필요할 때는 처리할 수 없고, 반대로 너무 큰 배열을 선언하면
 * 그만큼 메모리가 낭비되거나 프로그램이 강제로 종료될 수 있다. 메모리 낭비는 최소화하면서 배열의 크기를 
 * 지정할 수는 없다. 
 */

/**
 * 동적 메모리 할당과 해제하기
 * 
 * 이럴 때 동적 메모리 할당을 사용한다. 동적 메모리 할당(dynamic memory allocation)은 프로그램 실행 중에도
 * 필요한 크기의 메모리를 운영체제에 요청하여 사용할 수 있는 방법이다. 
 * 
 * C++ 언어에서 동적 메모리를 할당하려면 new 키워드를 사용한다. 
 * 
 * => 자료형 *변수_이름 = new 자료형;
 * 
 * new로 할당된 메모리는 필요 없는 시점에 delete 키워드로 반드시 직접 해제해야 한다. 
 * 
 * => delete 변수_이름;
 */

#include <iostream>
using namespace std;

int main() {

	int* pt_int_array_value = new int[5];	// 동적 메모리 할당(배열)

	for (int i = 0; i < 5; i++)
	{
		pt_int_array_value[i] = i;	// 할당된 배열 변수에 0 ~ 4까지 순서대로 넣기 
	}

	for (int i = 0; i < 5; i++)
	{
		cout << pt_int_array_value[i] << endl;	// 배열 변수 출력 
	}

	delete[] pt_int_array_value;	// 동적 메모리 해제(배열)

	return 0;
}

/*
0
1
2
3
4
*/

/**
 * 이 예시에서 유의해서 봐야할 부분은 메모리 해제 코드다. 배열 형태로 메모리를 할당했다면
 * 똑같은 배열 형태로 메모리를 해제해야 한다. 그렇지 않으면 해제되지 않는 메모리 때문에
 * 메모리 누수(memory leak)가 발생한다. 동적 메모리를 사용할 때는 항상 new와 delete를
 * 한 쌍으로 생각하고 사용해야 한다. 
 */

/**동적 할당 메모리를 해제하는 이유
 * 
 * 일반 변수와 달리 동적으로 할당한 메모리를 해제해야 하는 이유는 각각 사용하는 메모리의
 * 영역이 다르기 때문이다. 
 * 
 * 함수의 매개변수나 지역 변수처럼 대부분의 일반 변수는 스택(stack)이라는 메모리 영역에 
 * 할당된다. 스택 영역은 함수의 호출과 함께 할당되며 함수가 반환되면 자동으로 소멸한다. 
 * 따라서 메모리 해제를 관리할 필요가 없다. 하지만 일반적으로 스택 영역은 크기가 한정되어
 * 있으며, 이 크기를 초과할 때는 운영체제가 해당 프로그램을 강제로 종료한다. 
 * 
 * 반면에 동적으로 할당된 변수는 힙(heap)이라는 메모리 영역에 존재한다. 힙은 스택보다
 * 훨씬 큰 메모리 풀이므로 크기가 큰 배열도 충분히 할당할 수 있다. 그런데 힙에 할당된
 * 메모리는 명시적으로 해제하기 전에는 해당 프로그램이 종료될 때까지 계속 유지된다. 
 * 따라서 메모리 해제를 적절하게 하지 않으면 프로그램이 동작하면서 조금씩 메모리 누수가
 * 누적된다. 그리고 이는 메모리를 과다하게 사용하는 문제로 발전한다. 따라서 동적 메모리를
 * 사용할 때 메모리 해제를 철저히 하는 것을 잊지 말도록 한다. 
 */