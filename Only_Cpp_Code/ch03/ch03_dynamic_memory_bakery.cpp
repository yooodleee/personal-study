// 방문하는 손님 수만큼 빵 만들기

/**
 * 포인터와 동적 메모리 할당
 * 
 * 포인터와 동적 메모리 할당을 연습하는 차원으로 방문하는 손님 수만큼 빵을 만들도록 한다. 
 * 매일 가게에 방문하는 손님 수만큼 빵을 만드는 것이 목표이다. 
 */

#include <iostream>
#include <string>


using namespace std;

int main() {

	int customer_num = 0;

	cout << "오늘 방문 손님: ";
	cin >> customer_num;	// 손님 수 입력

	string* bread = new string[customer_num];	// 손님 수 만큼 string 배열 생성 

	for (int i = 0; i < customer_num; i++)	// 입력 받은 손님 수만큼 반복 
	{
		bread[i] = "빵_" + to_string(i);		// '빵_숫자' 형태로 배열에 저장, to_string => 숫자를 문자열로 변환 
	}

	cout << endl << "--생산된 빵--" << endl;
	for (int i = 0; i < customer_num; i++)
	{
		cout << *(bread + i) << endl;	// 생산된 빵 출력 (포인터 연산 참고)
	}

	delete[] bread;	// string 배열 삭제(해제)

	return 0;
}

/**
 * 실행 결과 
 * 
 * 오늘 방문 손님 : 3 (enter)
 * 
 * --생산된 빵--
 * 빵_0
 * 빵_1
 * 빵_2
 */


/**
 * 포인터를 다룰 때 주의할 점 
 * 
 * 포인터는 주소를 다루므로 강력하지만 그만큼 다루기가 쉽지 않다. 몇 가지 주의할 점을
 * 살펴보겠다. 먼저 포인터를 역참조하기 전에 포인터가 유효한 메모리를 가리키는지 확인해야 한다. 
 * 포인터를 선언한다고 해서 자동으로 유효한 메모리를 가리키는 것은 아니다. 유효하지 않은 메모리를
 * 가리키는 포인터를 역참조하려고 하면 세그멘테이션 실패나 런타임 오류가 발생할 수 있다. 
 * 
 * 또 하나 주의할 점은 할당된 메모리의 범위를 벗어나는 포인터 연산은 피해야 한다. 예컨대 정수 5개로
 * 구성된 배열이 있고, 배열의 첫 번째 원소를 가리키는 포인터를 선언했다고 가정하자. 이때 배열에서
 * 6번째 원소를 가리키려고 하면 배열에 해당하지 않은 메모리에 접근하게 되어 정의되지 않은 동작이
 * 발생할 수 있다. 
 * 
 * 마지막으로 할당 해제된 메모리를 역참조하지 말아야 한다. 포인터가 가리키는 메모리를 할당 해제하고
 * 그 포인터를 역참조하려고 하면 정의되지 않은 동작이 발생할 수도 있다. 
 */

