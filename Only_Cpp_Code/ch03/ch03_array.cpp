// 배열 선언과 원소에 접근하기

/**다중 포인터
 * 
 * 포인터가 메모리 주소를 저장하는 '변수'라는 것은 포인터가 차지하는 공간 역시 주소를
 * 가지고 있음을 의미한다. 그렇다면 포인터 변수의 주소를 저장하는 또 다른 포인터도
 * 만들 수 있을까? 포인터를 가리키는 포인터(pointer to pointer)를 의미하는 다중 포인터
 * (multiple pointer)를 사용할 수 있다. 
 * 
 * 다중 포인터를 이용하는 간단한 예를 살펴보자. 
 * 
 * #include <iostream> 
 * 
 * int main()
 * {
 * 		int int_value = 123;
 * 
 * 		int *int_pt_value = &int_value;
 * 		int **int_pt_pt_value = &int_pt_value;
 * 		int ***int_pt_pt_pt_value = &int_pt_pt_value;
 * 
 * 		return 0;
 * }
 * 
 * 예에서 삼중 포인터 변수인 int_pt_pt_pt_value를 역참조해 int_value의 데이터에 접근하는 과정을 살펴보겠다. 
 * 먼저 int_pt_pt_pt_value에 역참조 연산자 *를 적용하면 메모리의 117 번지를 찾아간다. 
 * 117 번지에는 106이라는 주소가 저장돼 있다. 여기서 한번 더 * 연산자를 적용하면(**int_pt_pt_pt_value) 106 번지를
 * 찾아간다. 106 번지에는 100이라는 주소가 있다. 여기서 다시 * 연산자를 추가하면(***int_pt_pt_pt_value) 100번지를 
 * 찾아가 비로소 int_value 변수에 저장된 정수 123에 접근할 수 있다. 
 * 
 * 즉, 삼중 포인터 변수는 역참조 연산자 *를 3번, 이중 포인터 변수는 2번, 단일 포인터 변수는 1번 적용해야 값에 접근할
 * 수 있다. 
 */

/**배열과 포인터
 * 
 * 포인터를 다루면서 배열과의 관계를 빼놓을 수가 없다. 먼저 배열이 무엇인지부터 살펴보자. 
 * 예컨대, 로또 추첨 프로그램을 만들기 위해 로또 번호 45개에 해당하는 정수형 변수가 필요하다고 
 * 가정해보자. 변수를 45개 선언하고 값을 넣으려면 너무 많아서 번거롭다. 
 * 
 * 이때 배열을 이용하면 간단하게 만들 수 있다. 배열은 여러 개 모인 것으로, 같은 자료형의 변수를 연속으로
 * 늘어놓은 형태다. 배열을 선언한 후, 배열_이름 [인덱스] 처럼 [] 안에 인덱스(index)라고 하는 차례 번호를 넣으면 
 * 해당 순서의 원소에 접근할 수 있다. 
 */

/**배열 선언과 원소에 접근하기
 * 
 * 배열의 선언과 원소에 접근하는 코드를 확인해보자. 이 코드에서는 길이가 45인 고정 배열(fixed array)을 선언했다. 
 * 고정 배열은 컴파일 타임에 길이를 알고 있는 배열이다. 잠시 뒤에는 동적 배열(dynamic array)을 알아볼 것인데, 
 * 동적 배열의 길이는 런타임에 길이를 변경할 수 있다. 
 */

#include <iostream>
using namespace std;

int main() {

	int lotto[45] = {
		1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
		16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
		31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45
	};

	cout << "Today's Lotto : "
		<< lotto[0] << ", " << lotto[7] << ", " << lotto[15] << ", "
		<< lotto[27] << ", " << lotto[36] << ", " << lotto[44] << endl;

	return 0;
}

/**
 * 배열의 각 원소는 연속으로 붙어 있다. 이는 원소의 메모리 주소를 확인해 보면 더 명확하게 확인할 수 
 * 있다. 주소 연산자 &로 출력해 보면 16진수의 메모리 주소가 4씩 차례로 증가하는 것을 볼 수 있다. 
 * 메모리 주소가 4씩 증가하는 것은 int 형이 4 byte이기 때문이다. 
 */