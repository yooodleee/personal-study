// bank 클래스 정의하기

/**
 * 추상화와 캡슐화
 * 
 * 추상화란(abstraction)는 공통된 특징은 추출하고 불필요한 부분은 제거하여 코드를 간결하고 이해하기 쉽게
 * 만드는 작업이다. 복잡한 자료, 모듈 시스템 등으로부터 핵심 개념이나 기능을 간추리는 것을 말한다. 
 * 
 * 추상화가 객체지향 프로그래밍에서 가장 중요한 이유는 클래스를 만드는 과정과 밀접한 관계가 있기
 * 때문이다. 클래스는 표현하고자 하는 대상의 공통 특징을 속성과 기능으로 구분하여 멤버 변수와 
 * 멤버 함수로 만드는 것이다. 대상을 추상화하여 클래스로 만들면 코드의 불필요한 부분을 줄이고 범용성과 
 * 재사용성을 높일 수 있다는 장점이 있다. 
 * 
 * * 공통 특징 추출하기
 * 추상화는 대상의 공통된 특징을 추출하는 데서 시작한다. 예컨대 자동차는 용도에 따라 엔진 종류, 바퀴 개수,
 * 크기 등에는 차이가 있지만, '바퀴와 엔진이 있고 사람이나 짐을 싣고 이동할 수 있다'는 공통된 특징이 있다. 
 *      - 짐을 싣는다. 
 *      - 이동한다. 
 *      - 바퀴
 *      - 엔진
 *      - 사람을 태운다. 
 * 
 * 추상화는 이처럼 어떤 대상이 속한 집단에서 공통된 특징을 추출하여 정의하는 과정이다. 그리고 추상화한 내용을
 * 바탕으로 클래스를 만들 수 있다. 엔진과 바퀴라는 멤버 변수 2개와 사람 태우기, 짐 싣기, 이동하기라는 멤버 
 * 함수 3개로 추상화한 자동차 클래스를 다이어 그램으로 표현하면 다음과 같다. 
 * 
 * (자동차 클래스)
 *      - 엔진
 *      - 바퀴
 * ==================
 * - 사람을 태운다. 
 * - 짐을 싣는다. 
 * - 이동한다. 
 * 
 * * 불필요한 요소 제거하기
 * 불필요한 요소를 제거하는 것도 추상화의 한 과정이다. 이번엔 병원 운영 애플리케이션을 만든다고 가정해보자. 
 * 병원 운영 애플리케이션에는 고객의 이름, 주소, 핸드폰 번호 등과 같은 정보가 필요하다. 반면에 직업, 취미,
 * 특기, 좋아하는 음식 같은 정보는 필요하지 않을 수 있다. 이처럼 불필요한 정보를 제거하는 것도 추상화라고
 * 할 수 있다. 
 * 
 * (병원 고객)          =>          (병원 고객)
 * - 이름                            - 이름
 * - 주소                            - 주소
 * - 휴대폰 번호                     - 휴대폰 번호
 * - 직업
 * - 취미
 * - 특기
 * - 좋아하는 음식
 * 
 * 정리하면 추상화란 그가 속한 집단에서 개별적인 특징은 빼고 대표하는 특징만 뽑아서 정의하는 과정이다. 
 * 
 * 
 * * 캡슐화란 무엇인가?
 * 
 * 객체지향 프로그래밍의 두 번째 특징으로 캡슐화(capsulation)를 알아보겠다. 캡슐화는 변수와 함수를 클래스로
 * 감싸서 외부에서는 개별적으로 접근할 수 없도록 하나로 묶어서 관리하는 것을 의미한다. 즉, 캡슐화는 클래스 
 * 밖에서 내부의 멤버에 접근할 수 없도록 정보를 은닉화(hiding)한다. 
 * 
 * 이처럼 정보를 클래스로 캡슐화하면 외부에서는 내부의 세세한 로직을 알 필요가 없으며 혹시 로직이 변경되더라도
 * 외부에 영향을 주지 않는다. 따라서 복잡도는 낮아지고 재사용성은 높아진다. 
 * 
 * * 은닉화와 접근 지정자
 * 
 * 클래스로 캡슐화한 멤버 변수나 멤버 함수도 여러 클래스를 만들어 사용할 때 클래스끼리 변수나 함수에 마음대로
 * 접근하면 의도하지 않은 오류가 발생할 수 있다. 이런 문제를 해결하는 방법이 은닉화다. C++에서는 은닉화를 위해
 * 접근 지정자(access specifier)를 제공한다. 클래스의 멤버를 선언할 때는 접근 지정자를 지정해야 하며, 만약 
 * 지정하지 않으면 default로 private으로 선언되낟. 참고로 C++에서는 구조체도 멤버 함수를 포함할 수 있다. 구조체의
 * 기본 접근 지정자는 클래스와 다르게 public으로 선언된다. 
 * 
 * (접근 지정자)
 *      - private: 클래스 내의 멤버 함수에서만 접근 가능
 *      - public: 다른 클래스 어디서든 접근 가능
 *      - protected: 클래스 내의 함수나 상속 관계의 클래스에서 접근 가능
 * 
 * private으로 선언한 멤버는 같은 클래스 안의 멤버 함수에서만 접근할 수 있다. 그리고 public으로 선언한 멤버는 다른
 * 클래스 어디서든 접근할 수 있다. 외부로 노출해야 하는 멤버를 공유하는 접근 지정자이다. 마지막으로 protected로 
 * 선언한 멤버는 같은 클래스 내의 멤버 함수나 상속 관계의 클래스에서 접근할 수 있다. 
 * 
 * * 접근 지정자 적용하기
 * 
 * 이제 앞서 살펴본 내용을 코드로 작성해보자. 먼저 bank라는 클래스를 다이어그램으로 표현해 보면 다음과 같다. 
 * 
 *                    (bank)
 *      ------------------------------------
 *      | - safe: int                      |     => private은 -로 표기
 *      ------------------------------------     
 *      | + use_counter(int, int) : void   |     => public은 + 로 표기 
 *      ------------------------------------
 * 
 * 참고로 클래스 다이어그램에서 멤버 앞에 - 기호는 private 멤버를 의미하며, + 기호는 public 멤버를 의미한다. 
 * 금고를 나타내는 멤버 변수 safe는 private으로 지정했고, 창구를 나타내는 멤버 함수 use_counter는 public으로
 * 지정했다. 그리고 use_counter 함수는 입금액과 출금액을 매개변수로 받아서 금고에서 가감하도록 구현할 수 있다. 
 */

#include <iostream>

using namespace std;


class bank {
private:
    int safe;   // 금고


public:
    bank();     // 기본 생성자
    void use_counter(int _in, int _out);    // 입출금 창구 함수

};

bank::bank() {
    safe = 1000;    // 은행 금고 초기 금액 설정
    cout << "최초 금고 : " << safe << endl;
    cout << endl;
}

void bank::use_counter(int _in, int _out) {
    safe += _in;    // 입금
    safe -= _out;   // 출금

    cout << "입금 : " << _in << endl;
    cout << "출금 : " << _out << endl;
    cout << "금고 : " << safe << endl;
    cout << endl;
}

int main() {
    bank my_bank;   // my_bank 인스턴스 생성(클래스가 메모리에 할당되어 생성된 변수=객체object)
    // bank 클래스의 멤버 함수인 use_counter를 호출할 수 있음.

    my_bank.use_counter(0, 20); // 출금 20
    my_bank.use_counter(50, 0); // 입금 50
    my_bank.use_counter(100, 50);   // 입금 100, 출금 50

    return 0;
}

/**
 * 실행 결과
 * 
 * 최초 금고: 1000
 * 
 * 입금: 0
 * 출금: 20
 * 금고: 980
 * 
 * 입금: 50
 * 출금: 0
 * 금고: 1030
 * 
 * 입금: 100
 * 출금: 50
 * 금고: 1080
 */

/*
용어 정리

* 객체(object): 논리적 개념으로 클래스로 구현하고자 하는 구현 대상, 또는 인스턴스를 달리 부를 때 사용
* 클래스(class): 객체를 구현하기 위한 설계도
* 인스턴스(instance): 클래스 정의에 따라 메모리에 실체화된 객체의 형태태
*/

/**
 * main 함수에서 첫 줄에 있는 bank my_bank 코드는 '인스턴스(instance)'를 생성하는 코드이다. 인스턴스는 
 * 클래스가 메모리에 할당되어 생성된 변수를 말한다. 객체와 같다. 객체라는 용어는 논리적인 개념으로 
 * 사용할 때가 많고 생성된 객체를 만들 때는 '인스턴스'라는 용어를 사용한다. 
 * 
 * main 함수에서 첫 줄에 있는 bank my_bank 코드는 bank 클래스를 사용할 수 있는 인스턴스 1개를 만들어 
 * my_bank라는 이름을 붙였다. 따라서 이후 코드에서 my_bank라는 이름으로 bank 클래스의 멤버 함수인 
 * use_counter를 호출할 수 있다. 
 */