// public 멤버 변수 접근

/**
 * 접근 지정자와 프렌드
 * 
 * 접근 지정자는 객체지향 프로그래밍에서 캡슐화를 구현하는 수단이다. C++ 언어는 접근 지정자로 
 * 객체 지정자로 객체의 멤버 접근 권한을 세밀하게 설정할 수 있다. 하지만 잘못 사용하면 접근
 * 권한이 의도치 않게 설정되므로 주의해야 한다. 
 */

/**
 * 상속에 따른 접근 지정자의 변화
 * 
 * 캡슐화에 대해 알아보기 이전에, 먼저 접근 지정자에 대해 다시 살펴보자. 우선순위는 상속에서 접근 
 * 지정자가 적용되는 우선순위를 의미한다. 
 * 
 * --------------------------------------------------------------------------------
 * |  private  |  클래스 내 멤버 함수만 접근 가능, 상속받은 클래스 접근 불가 |  높음  |
 * ---------------------------------------------------------------------------------
 * |   public  |  다른 클래스 어디서든 접근 가능, 상속받은 클래스에서 접근   |  낮음  |
 * ---------------------------------------------------------------------------------
 * | protected |  클래스 내 멤버 함수에서 접근 가능, 상속받은 클래스에서 접근|  중간  |
 * ---------------------------------------------------------------------------------
 * 
 * 접근 지정자는 클래스에서 멤버 변수를 정의하거나 상속받을 때 주로 사용한다. 클래스를 정의할 때는 
 * 선언부에서 public, private, protected 키워드와 쌍점(:)을 작성하고 그 아래쪽에 해당 접근 지정자로 
 * 정의할 멤버를 작성한다. 그리고 클래스를 상속받을 때는 부모 클래스 이름 앞에 접근 지정자를 작성한다. 
 * 만약 접근 지정자를 생략하면 기본 접근 지정자(default access specifier)가 적용되는데, C++에서 기본
 * 접근 지정자는 private이다. 
 * 
 * 접근 지정자는 클래스 외부에서 접근과 상속받은 자식 클래스에서 접근을 제어한다. 외부 접근은 클래스 
 * 외부(예컨대 main 함수)에서 클래스 객체를 생성하고 이를 통해 멤버 함수나 변수에 접근하는 것을 말한다. 
 * 
 *                  monster_b : public monster          (monster)
 *                               
 *              public          =>              =>        public
 * --------     
 * | 외부 |     protected       =>      this    =>        protected
 * --------
 * 
 *              private         =>              =>        private
 * 
 * 
 * 자식 클래스에서 부모 클래스로 접근할 때 private으로 지정된 멤버에는 접근할 수 없다. 자식 클래스는 
 * 상속을 선언할 때 명시한 접근 지정자(이하 상속 접근 지정자)에 영향을 받아서 상속받은 부모 클래스의 
 * 멤버에 지정된 접근 권한이 변경된다. 즉, 상속 접근 지정자의 우선순위보다 낮은 접근 지정자는 모두
 * 상속 접근 지정자로 변경된다. 
 * 
 * 예컨대 상속 접근 지정자가 protected라면 부모 클래스의 public 멤버는 모두 protected 멤버로 변경된다. 
 * 또 상속 접근 지정자가 private라면 부모 클래스의 public, protected 멤버는 모두 private 멤버로 변경된다. 
 * 그러나 상속 접근 지정자가 public일 때는 부모 클래스의 접근 지정자를 그대로 따른다. public의 우선순위가
 * 가장 낮기 때문이다. 
 * 
 * 부모 클래스에서 private으로 지정한 멤버는 자식 클래스나 외부에서 모두 접근할 수 없다. 그리고 상속 접근
 * 지정자로 변경된 멤버 함수의 접근 지정자는 다시 상속받는 자식 클래스에 영향을 미친다. 
 */

/**
 * 멤버 변수 공개를 지양해야 하는 이유
 * 
 * 멤버 변수를 public으로 공개하면 어느 곳에서나 자유롭게 접근할 수 있다. 자유로운 접근은 멤버 변수의 값이
 * 의도하지 않게 설정되어 오류가 발생하기도 한다. 예컨대 배열의 인덱스를 저장하는 멤버 변수의 값은 0보다 
 * 작거나 배열 전체 크기보다 크면 오류가 발생한다. 배열의 인덱스가 public으로 공개된 멤버 변수라면 클래스
 * 외부에서 음수로 설정해도 컴파일 오류가 발생하지 않는다. 하지만 배열을 인덱스로 접근할 때 문제가 발생한다. 
 */

#include <iostream>
#include <array>

using namespace std;


class manage_data_structor {
public:
    manage_data_structor();
    int current_index;
    array<int, 10> data_queue;
};

manage_data_structor::manage_data_structor() :
    current_index(0), data_queue{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} {
}


int main(void) {
    int data;
    manage_data_structor data_structor;

    data_structor.current_index = -1;
    data = data_structor.data_queue[data_structor.current_index];

    cout << "Data [" << data_structor.current_index << "] : " << data << endl;

    return 0; 
}

/**
 * 비쥬얼 스튜디오에서는 인덱스 범위가 벗어난 논리 오류를 다음처럼 경고로 보여 준다. 무시하고
 * 실행할 수 있지만 프로그램은 오류가 발생하여 비정상으로 종료된다. 이 코드는 간단하고 오류가 
 * 명료해서 컴파일러가 경고를 해주지만, 소스 코드가 복잡해지고 양이 많으면 오류를 찾아내지 못
 * 할 수도 있다. 
 * 
 * (필드)std::array<int 1OUI64> manage_data_structure::data_queue
 * C28020: 이 호출에서 '0 <= _Param_(1)&&_Param_(1)<=10-1' 식이 true가 아닙니다. 
 */