#5장 자료구조



#5.1 리스트

#앞에서 변수를 배울 때 나이, 이름, 취미 등 서로 다른 의미의 값들을 각각 변수에 저장해서 사용했다.
#그렇다면 관련 있는 값을 여러 개 사용할 때는 어떻게 저장을 할까?


#5.1.1 리스트 생성하기

subway1=10
subway2=20
subway3=30 #지하철 칸 별로 10, 20, 30명 승차

#현재는 3칸밖에 없지만, 지하철이 수십 칸이라면 변수도 수십개가 돼야 함->리스트(list)를 사용하면 변수 하나로 관리할 수 있다.
#형식:리스트명=[값1, 값2, ...]
#변수마다 값을 하나씩 넣었던 것과 달리 리스트는 값을 여러 개 넣을 수 있다-> 하나의 변수가 하나의 가질 수 있었다면 하나의 리스트는 여러 값을 가질 수 있다.각 값의 자료형은 다를 수 있다.
#같은 값의 중복을 허용한다!

subway=[10,20,30]
print(subway) #subway1, subway2, subway3 변수를 사용할 필요 없이, subway 리스트 하나에 저장할 수 있음


#5.1.2 값 추가/삽입/삭제하기

subway=["푸","피글렛","티거"]
print(subway)

#문자열에서 인덱스는 데이터의 위치를 나타낸다.리스트에서도 인덱스로 리스트에 저장된 데이터의 위치를 표시한다.
#리스트도 문자열처럼 리스트명에 대괄호를 붙이고 그 안에 인덱스를 넣으면 그 위치에 해당하는 값에 접근할 수 있다.

print(subway.index("피글렛")) #1, 인덱스는 0부터 시작한다는 점을 잊지 말자!

#리스트에서 값을 추가할 때는 append() 함수를 사용한다.
#형식: append(추가할 값)
#리스트 끝에 값을 추가한다.

subway.append("이요르")
print(subway.index("이요르")) #3, 티거 뒤에 이요르

#푸와 피글렛이 탄 칸 사이에 새로운 칸이 삽입되고 여기에 루가 탔다고 하자.
#리스트에서는 insert() 함수로 중간에 값을 삽입할 수 있다.-> 삽입할 위치는 인덱스로 지정한다.
#형식: insert(인덱스, 삽입할 값)

subway.insert(1, "루") 
print(subway) #루를 푸와 피글렛 사이(인덱스1)에 삽입

#목적지에 도착해 역마다 한 명씩 지하철에서 내린다.-> pop() 함수를 사용한다.
#리스트 끝에서부터 값을 하나씩 꺼내어 반환한 뒤 삭제한다.

print(subway.pop())
print(subway)   #이요르 내림

print(subway.pop())
print(subway)   #티거 내림

print(subway.pop())
print(subway)   #피글렛 내림

#종착역에서는 남은 승객이 모두 내린다.리스트에서는 값이 더 이상 필요없을 때 또는 새로운 값을 저장하고 싶을 때 clear() 함수를 사용한다.

subway.clear()
print(subway) #지하철에서 모두 내림, subway 리스트에는 아무 값도 없다.


#5.1.3 중복 값 확인하기

#문자열과 마찬가지로 count() 함수를 사용하면 리스트 안에 같은 값이 몇 개인지 확인 가능하다.
#지하철에 있던 인원에서 푸를 뒤에 한 명 더 태우겠다.
#리스트에 푸가 몇 명 있는지 확인하자

subway=["푸", "피글렛","티거"]
subway.append("푸") #푸 추가
print(subway)
print(subway.count("푸")) #푸가 몇 명 있는가 확인, 2


#5.1.4 리스트 정렬하기

num_list=[5,4,3,2,1]

#여기에 sort() 함수를 사용하면 뒤섞인 숫자를 오름차순으로 정렬할 수 있음

num_list.sort()
print(num_list) #오름차순 정렬, [1,2,3,4,5]

#이때 sort() 함수에 다음과 같이 추가하면 리스트를 내림차순으로 정렬할 수도 있다.

num_list.sort(reverse=True) 
print(num_list) #내림차순 정렬, [5,4,3,2,1]

#리스트에 reverse() 함수를 사용하면 값의 순서를 거꾸로 뒤집을 수 있다.

num_list.reverse()
print(num_list) #순서 뒤집기, [1,2,3,4,5]


#추가 개념 sorted() 로 리스트 정렬하기

#sort() 함수는 정렬하면서 리스트 자체의 값을 변경
#sorted() 함수는 원본 리스트 변경 없이 정렬된 리스트를 새로 생성

my_list=[1,2,3]
my_list.sort() #리스트 정렬
print(my_list) #my_list 리스트 데이터 변경, [1,2,3]

your_list=[1,3,2]
new_list=sorted(your_list) #정렬할 리스트를 소괄호 안에 넣음
print(your_list) #your_list 리스트 데이터는 변경되지 않음, [1,3,2]
print(new_list) #정렬된 새로운 리스트, [1,2,3]


#5.1.5 리스트 확장하기

#리스트에 반드시 같은 자료형의 값만 넣을 필요는 없다.
#정수형, 실수형, 문자열, 불 형, 심지어 리스트도 집어 넣을 수 있다.

mix_list=["푸", 20, True, [5,4,3,2,1]] #문자, 정수, 불, 리스트
print(mix_list)

#서로 다른 리스트를 합칠 수도 있다.-> extend() 함수를 사용하면 된다.
#형식: 리스트1.extend(리스트2)

mix_list=["푸", 20, True]
num_list=[5,4,3,2,1]
num_list.extend(mix_list) #리스트 합치기
print(mix_list)
print(num_list)


#추가 개념 리스트에서 함수 사용

#리스트에서 사용할 수 있는 함수 중에서 append(), insert(), clear(), sort(), reverse(), extend()는 별도 문장으로 실행한 뒤 변경된 리스트의 내용을 print 출력했다.
#index(), pop(), count()는 print문 안에서 실행과 동시에 값을 출력했다.

#별도 문장으로 실행하는 함수들은 수행 후 반환하는 값 없이 리스트 자체가 변경된다.
#print(subway.append("이요르"))라고 작성하고 실행하면 None값을 출력한다.



#5.2 딕셔너리(dictionary)

#리모컨키와 자동차가 한 쌍을 이루는 것처럼 딕셔너리는 값이 key와 value 한 쌍으로 이루어져 있다.
#영어를 공부할 때 영한사전을 보면 영어 단어가 있고 옆에 뜻이 설명돼 있는 것처럼


#5.2.1 딕셔너리 생성하기

#형식: 딕셔너리명={key1:value, key2:value2, ...}
#key와 value는 콜론(:)으로 구분하고, key와 value 한 쌍으로 이루어진 각 값은 쉼표로 구분한다.
#이때 key는 중복을 허용하지 않으므로 유일한 값으로 설정해야 한다.(자동차 리모컨), key는 변하지 않는 값을 사용해야 한다.-> 리스트와 세트도 변하는 값은 사용할 수 없다.

#푸와 친구들이 목욕탕에 가서 각자 사물함 열쇠를 받는다고 하자.푸는 3번 사물함 열쇠를, 피글렛은 100번 사물함 열쇠를 받았다.
#사물함 열쇠와 사용자 할당 관계를 딕셔너리로 표현해보자.

#사물함 열쇠를 key로, 사용자 이름을 value로 넣어 cabinet이라는 딕셔너리를 정의하자.

cabinet={3:"푸", 100:"피글렛"}

#각 사물함이 누구에게 할당됐는지 확인해보자.
#변수나 리스트가 인덱스로 값에 접근한다면 딕셔너리는 인덱스 역할을 key가 한다.-> 딕셔너리명에 대괄호를 붙이고 그 안에 key를 넣으면 key에 해당하는 value에 접근가능하다.

print(cabinet[3]) #key 3에 해당하는 value, 푸
print(cabinet[100]) #key 100에 해당하는 value, 피글렛

#대괄호 대신 get() 함수를 사용해도 알 수 있다.

print(cabinet.get(3)) #key 3에 해당하는 value, 푸

#그런데 대괄호를 사용할 때와 get() 함수의 결과가 완전히 같지는 않다.
#대괄호 사용시, 만약 정의되지 않은 key를 전달하면 오류 발생하고 프로그램을 바로 종료함
#get() 함수 사용시, 정의되지 않은 key를 전달하더라도 오류가 발생하지 않고, None을 출력한다.그리고 프로그램은 계속 실행된다.

print(cabinet.get(5)) #정의되지 않은 key 5, None 출력하고 프로그램은 계속 실행
print("hi")
#print(cabinet[5]) 정의되지 않은 key 5, 오류가 발생하고 프로그램을 바로 종료(hi가 출력되지 않음)
print("hi")

#5번 사물함은 아직 사용자가 없으니 이름 대신 '사용 가능'이라는 기본값으로 설정하고자 한다.-> get() 함수를 사용한다
#get() 함수로 기본값을 설정하면 5번 열쇠를 누군가 사용하기 전까지, 즉 key 5에 해당하는 value를 정의하기 전까지는 '사용 가능'으로 나온다.

print(cabinet.get(5, "사용 가능")) #key 5에 해당하는 값이 없으면 기본값을 사용하게 함

#사물함이 사용 중인지도 확인할 수 있다.-> key가 딕셔너리에 있는지 확인, in 연산자 사용
#자료구조에 해당 key가 있을 때 True를, 없을 때 False를 반환

print(3 in cabinet) #True
print(5 in cabinet) #False


#추가 개념 get()

#get() 함수: get(key, default=None)
#key에 해당하는 value가 없으면 오류가 발생한느 대신 뒤에 있는 기본값 None을 반환함->print() 함수로 출력하면 None이 결과로 나옴
#여기서 기본값을 "사용 가능"으로 설정한다는 것은 key에 해당하는 value가 없으면 None 대신 "사용 가능"이라는 값을 반환하라는 의미


#key에는 정수형 뿐만 아니라 문자열에도 넣을 수 있다.

cabinet={"A-3":"푸", "B-100":"피글렛"}
print(cabinet["A-3"]) #푸
print(cabinet["B-100"]) #피글렛


#추가 개념 in 연산자

#문자열에 해당 글자가 포함됐는지 확인할 때도 사용가능

print("곰" in "곰돌이") #True
print("돌이" in "곰돌이") #True


#5.2.2 값 변경/추가/삭제하기

#값을 바꾸거나 값을 새로 추가하는 작업은 모두 대괄호를 사용한다.

cabinet={"A-3":"푸", "B-100":"피글렛"}
print(cabinet)
cabinet["A-3"]="티거" #key에 해당하는 값이 있을 때-> 변경
cabinet["C-20"]="이요르" #key에 해당하는 값이 없을 때-> 추가
print(cabinet) #{'A-3': '티거', 'B-100': '피글렛', 'C-20': '이요르'}

#대괄호에 key를 넣어 딕셔너리에 접근했을 때 결과는 2가지
#key에 해당하는 값이 있으면 key를 유지하면서 기존 value를 새로운 value로 변경함
#key에 해당하는 값이 없으면 key와 value 한 쌍으로 된 값을 딕셔너리에 새로 추가함

del cabinet["A-3"] #key 'A-3'에 해당하는 값 삭제
print(cabinet) #{'B-100': '피글렛', 'C-20': '이요르'}

#추가 개념 키워드(keyword)

#파이썬에서 사용이 예약된 문자열로 다른 용도로는 사용할 수 없음
#연산자 and, or, not, True, False, 제어문에 사용하는 if, for, while 등에 해당한다.


#5.2.3 값 확인하기

#딕셔너리에 있는 key만 확인하고 싶을 때-> keys() 함수를 사용함

print(cabinet.keys()) #key만 출력, dict_keys(['B-100', 'C-20'])

#values() 함수로 딕셔너리에 있는 모든 value를 확인

print(cabinet.values()) #value만 출력, dict_values(['피글렛', '이요르'])

#items() 함수로 key와 value 둘 다 확인

print(cabinet.items()) #key, value 한 쌍으로 출력, dict_items([('B-100', '피글렛'), ('C-20', '이요르')])

#딕셔너리에 있는 모든 값을 삭제할 떄 clear() 함수 사용

cabinet.clear()
print(cabinet) #{}



#5.3 튜플(tuple)

#리스트에서 '읽기'에 선택과 집중을 한, '리스트의 읽기 전용 버전' 정도로 이해하면 될 것 같다.
#리스트와 달리 처음 정의할 때를 제외하고 값의 변경이나 추가, 삭제 등이 불가능하다.-> 값의 순서도 바뀔 수 없다.
#리스트보다 속도가 빠르다.
#형식: 튜플명= (값1, 값2, ...)

menu=("돈까스", "치즈돈까스")
print(menu[0])
print(menu[1]) #튜플도 값은 인덱스로 확인한다.

#튜플은 값을 변경하거나 추가 또는 삭제할 수 없으므로 정의하고 값에 접근해 사용하는 것이 끝!

name="피글렛"
age=20
hobby="코딩"
print(name, age, hobby)

(name, age, hobby)=("피글렛", 20, "코딩")
print(name, age, hobby) #변수를 여러 줄에 따로 정의할 수도 있지만 튜플 형태로 한 줄에 여러 변수의 값을 정의할 수도 있다.

(departure, arrival)=("김포", "제주")
print(departure, ">", arrival) #김포>제주
(departure, arrival)=(arrival, departure)
print(departure, ">", arrival) #제주>김포



#5.4 세트(set)

#중복을 허용하지 않고, 데이터 순서도 보장하지 않는다.
#수학에서 집합을 표현할 때처럼 값을 쉼표(,)로 구분하고 중괄호로 정의한다.
#형식: 세트명={값1, 값2, ...}

my_set={1,2,3,3,3}
print(my_set) #중복을 허용하지 않으므로 같은 값은 여러 번 넣어도 실제로는 한 번만 저장함, {1,2,3}

#세트에는 정수, 문자열 등 다양한 형태의 값을 정의할 수 있다.
#중괄호 대신 set() 로 정의하는 방법도 있다.

java={"푸", "피글렛", "티거"} #자바 개발자 세트
python=set(["푸", "이요르"]) #파이썬 개발자 세트


#추가 개념 빈 세트 생성하기

empty_set=set()


#수학에서 집합의 성질 중 두 집합에서 공통 값을 뽑아내는 교집합이 있다.-> 교집합
#세트에도 같은 기능을 하는 & 기호와 intersection() 함수가 있다.

print(java&python) #자바와 파이썬을 모두 다룰 수 있는 개발자, {'푸'}
print(java.intersection(python)) #{'푸'}

#두 집합을 합치는 기능은 |(파이프, pipe) 기호나 union() 함수를 사용하면 된다.-> 합집합
#세트는 중복을 허용하지 않으므로 두 집합에 있는 공통으로 있는 값('푸')은 1번만 출력한다.

print(java|python) #{'티거', '푸', '피글렛', '이요르'}
print(java.union(python)) #{'티거', '푸', '피글렛', '이요르'}


#추가 개념 세트의 출력 순서

#세트는 데이터의 순서를 보장하지 않는다,
#따라서 세트에 저장한 값을 출력하면 실행할 때마다 결과가 달라진다.


#차집합은 -기호 또는 difference() 함수를 사용한다.

print(java-python) #{'티거', '피글렛'}
print(java.difference(python)) #{'티거', '피글렛'}

#값을 추가할 때는 add() 함수를 사용한다.

python.add("피글렛")
print(python) #{'이요르', '푸', '피글렛'}

#값을 제외할 때는 remove() 함수를 사용한다.

java.remove("피글렛")
print(java) #{'티거', '푸'}




#5.5 자료구조 변환하기

#리스트를 튜플로, 튜플을 세트로, 세트를 리스트로 자유롭게 변환할 수 있다.
#다음과 같이 세트 하나를 만든다,생성한 자료구조가 세트인지 확인한다.->type() 함수를 사용한다.
#소괄호 안에 확인하고 싶은 데이터를 넣고 print() 문으로 출력하면 데이터가 어떤 형태인지 알 수 있다.

menu={"커피", "우유", "주스"}
print(menu)
print(type(menu)) #<class 'set'>-> set는 클래스구나!

menu=list(menu)
print(menu, type(menu)) #리스트로 변환, ['커피', '주스', '우유'] <class 'list'>

#바꾸고 싶은 자료구조를 나타내는 명령어의 소괄호 안에 바꿀 자료명을 넣으면 된다.

menu=tuple(menu)
print(menu, type(menu)) #튜플로 변환, ('우유', '커피', '주스') <class 'tuple'>

menu=set(menu)
print(menu, type(menu)) #세트로 변환, {'커피', '우유', '주스'} <class 'set'>




#5.6 실습 문제: 당첨자 뽑기

#문제.댓글 작성자 중에서 추첨을 통해 1명은 치킨 쿠폰, 3명은 커피 쿠폰을 지급.
#조건.편의상 댓글은 20명이 작성하고, 아이디는 1~20이라고 가정함
#조건.무작위로 추첨하되 중복은 허용하지 않는다.
#조건.random 모듈의 shuffle() 과 sample() 함수를 활용한다.

from random import * #(1) random 모듈 추가

users=range(1,21) #(2) 리스트 생성, 1~21 직전(20)까지 연속한 숫자 모음
users=list(users) #(4) users를 리스트 자료구조로 변환
shuffle(users) #(3) 리스트 섞기

winners=sample(users,4) #(5) users 리스트에서 중복 없이(sample()) 4명 추첨

print("--당첨자 발표--") #(6) 당첨자 출력
print("치킨 당첨자 : {0}".format(winners[0])) #0번째 인덱스(1명)
print("커피 당첨자 : {0}".format(winners[1:])) #1번째 부터 마지막까지 슬라이싱(3명)
print("--축하합니다!--")

#(1) random 모듈의 shuffle()과 sample() 함수를 사용해야 하니 코드 가장 윗줄에 random 모듈을 가져오는 구문 추가

#(2) 1~20에 해당하는 아이디를 리스트로 만든다
#users=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
#일일이 아이디를 적기에는 귀찮으므로 range() 함수를 이용해서 작성하자.

#(3) users 리스트에 숫자를 직접 만든 경우라면 문제없지만, range() 함수로 숫자를 생성하면 오류가 발생한다.
#shuffle() 함수는 리스트에서만 사용할 수 있는데, range() 로 생성한 데이터는 리스트가 아니기 때문이다.

#(4) users 변수를 리스트로 변환

#(5) 리스트 데이터를 섞었으니 이번엔 추첨을 해보자.조건에 따라 20명 중 치킨 1명, 커피 3명이고 중복이 없어야 한다.
#sample() 함수를 사용해 처음부터 4명을 뽑은 다음, 그 중 1명은 치킨, 나머지 3명은 커피 당첨

#(6) winners에서 첫 번째 아이디는 치킨, 나머지는 커피 당첨자로 출력하면 된다.->슬라이싱을 사용하자.


from random import *

users=list(range(1,21)) #(1) range()를 list()로 바로 감싸서 한 줄 줄이기
shuffle(users)

chicken_winner=sample(users,1) #(2) 치킨 당첨자 1명 추첨
remain_users=set(users)-set(chicken_winner) #(3) 전체 집합에서 치킨 당첨자 제외
coffee_winner=sample(list(remain_users), 3) #(4) 남은 19명 중에서 3명 추첨, remain_users를 세트에서 리스트로 변환

print("--당첨자 발표--") #(5) 당첨자 출력
print("치킨 당첨자 : {0}".format(chicken_winner))
print("커피 당첨자 : {0}".format(coffee_winner))
print("--축하합니다--")

#(4) remain_users에는 이제 19명만 남으니 이 중 커피 당첨자 3명을 뽑으면 된다.
#그런데 추첨에 사용하는 sample() 함수에서 세트를 사용할 때 리스트로 자동 변환해 주는 기능이 3.9 버전부터 deprecated(사용을 권장하지 않으며 향후 폐지 예정)됨
#3.11 버전부터는 사용할 수 없게 바뀜->remain_users를 list() 또는 sorted() 함수를 사용해 세트에서 리스트 형태로 변환한 뒤에 sample() 함수를 사용해야 함


#추가 개념 파이썬 버전이 3.11 이상일 때

#shuffle() 함수를 사용할 수 없다.
#suffle() 함수와 동일한 동작을 수행하려면 sample() 함수를 사용하면 된다.
#다음 코드는 5개의 값을 가지는 리스트에서 len() 함수를 이용해 리스트 길이만큼, 즉 5개의 값을 무작위로 뽑는다.
#이때 뽑는 순서가 매번 달라질 수 있으므로 shuffle() 함수와 동일한 동작을 수행하게 된다.

from random import *

lst=[1,2,3,4,5] #shuffle(lst)
print(sample(lst,len(lst))) #[4, 2, 3, 1, 5]




#셀프 체크

#조건.신청 과목은 리스트로 관리된다.
#조건.리스트에 같은 과목이 2번 이상 포함된 경우 1개만 남기고 나머지는 삭제한다.
#조건.출력 시 신청 과목의 순서는 변경해도 괜찮다.

#힌트.자료구조는 서로 변환할 수 있다.
#힌트.세트는 중복을 허용하지 않는다.
#힌트.세트는 데이터의 순서를 보장하지 않으므로 실행할 때마다 실행결과의 순서는 달라질 수 있다.

subject=["자료구조", "알고리즘", "자료구조", "운영체제"]
subject=set(subject) #리스트를 세트로 변환해 중복 제거
subject=list(subject) #세트를 리스트로 변환
print("신청한 과목은 다음과 같습니다.")
print(subject) #['운영체제', '알고리즘', '자료구조']